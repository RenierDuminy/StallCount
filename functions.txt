[
  {
    "schema_name": "auth",
    "function_name": "email",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION auth.email()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.email', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')\n  )::text\n$function$\n"
  },
  {
    "schema_name": "auth",
    "function_name": "jwt",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION auth.jwt()\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n    coalesce(\n        nullif(current_setting('request.jwt.claim', true), ''),\n        nullif(current_setting('request.jwt.claims', true), '')\n    )::jsonb\n$function$\n"
  },
  {
    "schema_name": "auth",
    "function_name": "role",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION auth.role()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.role', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')\n  )::text\n$function$\n"
  },
  {
    "schema_name": "auth",
    "function_name": "uid",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION auth.uid()\n RETURNS uuid\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.sub', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')\n  )::uuid\n$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "armor",
    "args": "bytea",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.armor(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "armor",
    "args": "bytea, text[], text[]",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.armor(bytea, text[], text[])\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "crypt",
    "args": "text, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.crypt(text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_crypt$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "dearmor",
    "args": "text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.dearmor(text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_dearmor$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "decrypt",
    "args": "bytea, bytea, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.decrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "decrypt_iv",
    "args": "bytea, bytea, bytea, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt_iv$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "digest",
    "args": "bytea, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.digest(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "digest",
    "args": "text, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.digest(text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "encrypt",
    "args": "bytea, bytea, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.encrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "encrypt_iv",
    "args": "bytea, bytea, bytea, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt_iv$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "gen_random_bytes",
    "args": "integer",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.gen_random_bytes(integer)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_random_bytes$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "gen_random_uuid",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.gen_random_uuid()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/pgcrypto', $function$pg_random_uuid$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "gen_salt",
    "args": "text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "gen_salt",
    "args": "text, integer",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text, integer)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt_rounds$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "grant_pg_cron_access",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_cron'\n  )\n  THEN\n    grant usage on schema cron to postgres with grant option;\n\n    alter default privileges in schema cron grant all on tables to postgres with grant option;\n    alter default privileges in schema cron grant all on functions to postgres with grant option;\n    alter default privileges in schema cron grant all on sequences to postgres with grant option;\n\n    alter default privileges for user supabase_admin in schema cron grant all\n        on sequences to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on tables to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on functions to postgres with grant option;\n\n    grant all privileges on all tables in schema cron to postgres with grant option;\n    revoke all on table cron.job from postgres;\n    grant select on table cron.job to postgres with grant option;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "grant_pg_graphql_access",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.grant_pg_graphql_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    func_is_graphql_resolve bool;\nBEGIN\n    func_is_graphql_resolve = (\n        SELECT n.proname = 'resolve'\n        FROM pg_event_trigger_ddl_commands() AS ev\n        LEFT JOIN pg_catalog.pg_proc AS n\n        ON ev.objid = n.oid\n    );\n\n    IF func_is_graphql_resolve\n    THEN\n        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func\n        DROP FUNCTION IF EXISTS graphql_public.graphql;\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language sql\n        as $$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $$;\n\n        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last\n        -- function in the extension so we need to grant permissions on existing entities AND\n        -- update default permissions to any others that are created after `graphql.resolve`\n        grant usage on schema graphql to postgres, anon, authenticated, service_role;\n        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;\n        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;\n        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;\n\n        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles\n        grant usage on schema graphql_public to postgres with grant option;\n        grant usage on schema graphql to postgres with grant option;\n    END IF;\n\nEND;\n$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "grant_pg_net_access",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_net'\n  )\n  THEN\n    IF NOT EXISTS (\n      SELECT 1\n      FROM pg_roles\n      WHERE rolname = 'supabase_functions_admin'\n    )\n    THEN\n      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;\n    END IF;\n\n    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n\n    IF EXISTS (\n      SELECT FROM pg_extension\n      WHERE extname = 'pg_net'\n      -- all versions in use on existing projects as of 2025-02-20\n      -- version 0.12.0 onwards don't need these applied\n      AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')\n    ) THEN\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n\n      REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n      REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n\n      GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n      GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n    END IF;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "hmac",
    "args": "bytea, bytea, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.hmac(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "hmac",
    "args": "text, text, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.hmac(text, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "hypopg",
    "args": "OUT indexname text, OUT indexrelid oid, OUT indrelid oid, OUT innatts integer, OUT indisunique boolean, OUT indkey int2vector, OUT indcollation oidvector, OUT indclass oidvector, OUT indoption oidvector, OUT indexprs pg_node_tree, OUT indpred pg_node_tree, OUT amid oid",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.hypopg(OUT indexname text, OUT indexrelid oid, OUT indrelid oid, OUT innatts integer, OUT indisunique boolean, OUT indkey int2vector, OUT indcollation oidvector, OUT indclass oidvector, OUT indoption oidvector, OUT indexprs pg_node_tree, OUT indpred pg_node_tree, OUT amid oid)\n RETURNS SETOF record\n LANGUAGE c\n COST 100\nAS '$libdir/hypopg', $function$hypopg$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "hypopg_create_index",
    "args": "sql_order text, OUT indexrelid oid, OUT indexname text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.hypopg_create_index(sql_order text, OUT indexrelid oid, OUT indexname text)\n RETURNS SETOF record\n LANGUAGE c\n STRICT COST 100\nAS '$libdir/hypopg', $function$hypopg_create_index$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "hypopg_drop_index",
    "args": "indexid oid",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.hypopg_drop_index(indexid oid)\n RETURNS boolean\n LANGUAGE c\n STRICT COST 100\nAS '$libdir/hypopg', $function$hypopg_drop_index$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "hypopg_get_indexdef",
    "args": "indexid oid",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.hypopg_get_indexdef(indexid oid)\n RETURNS text\n LANGUAGE c\n STRICT COST 100\nAS '$libdir/hypopg', $function$hypopg_get_indexdef$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "hypopg_hidden_indexes",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.hypopg_hidden_indexes()\n RETURNS TABLE(indexid oid)\n LANGUAGE c\n STRICT\nAS '$libdir/hypopg', $function$hypopg_hidden_indexes$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "hypopg_hide_index",
    "args": "indexid oid",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.hypopg_hide_index(indexid oid)\n RETURNS boolean\n LANGUAGE c\n STRICT COST 100\nAS '$libdir/hypopg', $function$hypopg_hide_index$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "hypopg_relation_size",
    "args": "indexid oid",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.hypopg_relation_size(indexid oid)\n RETURNS bigint\n LANGUAGE c\n STRICT COST 100\nAS '$libdir/hypopg', $function$hypopg_relation_size$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "hypopg_reset",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.hypopg_reset()\n RETURNS void\n LANGUAGE c\n COST 100\nAS '$libdir/hypopg', $function$hypopg_reset$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "hypopg_reset_index",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.hypopg_reset_index()\n RETURNS void\n LANGUAGE c\n COST 100\nAS '$libdir/hypopg', $function$hypopg_reset_index$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "hypopg_unhide_all_indexes",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.hypopg_unhide_all_indexes()\n RETURNS void\n LANGUAGE c\n COST 100\nAS '$libdir/hypopg', $function$hypopg_unhide_all_indexes$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "hypopg_unhide_index",
    "args": "indexid oid",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.hypopg_unhide_index(indexid oid)\n RETURNS boolean\n LANGUAGE c\n STRICT COST 100\nAS '$libdir/hypopg', $function$hypopg_unhide_index$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "index_advisor",
    "args": "query text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.index_advisor(query text)\n RETURNS TABLE(startup_cost_before jsonb, startup_cost_after jsonb, total_cost_before jsonb, total_cost_after jsonb, index_statements text[], errors text[])\n LANGUAGE plpgsql\nAS $function$\ndeclare\n    n_args int;\n    prepared_statement_name text = 'index_advisor_working_statement';\n    hypopg_schema_name text = (select extnamespace::regnamespace::text from pg_extension where extname = 'hypopg');\n    explain_plan_statement text;\n    error_message text;\n    rec record;\n    plan_initial jsonb;\n    plan_final jsonb;\n    statements text[] = '{}';\nbegin\n\n    -- Remove comment lines (its common that they contain semicolons)\n    query := trim(\n        regexp_replace(\n            regexp_replace(\n                regexp_replace(query,'\\/\\*.+\\*\\/', '', 'g'),\n            '--[^\\r\\n]*', ' ', 'g'),\n        '\\s+', ' ', 'g')\n    );\n\n    -- Remove trailing semicolon\n    query := regexp_replace(query, ';\\s*$', '');\n\n    begin\n        -- Disallow multiple statements\n        if query ilike '%;%' then\n            raise exception 'Query must not contain a semicolon';\n        end if;\n\n        -- Hack to support PostgREST because the prepared statement for args incorrectly defaults to text\n        query := replace(query, 'WITH pgrst_payload AS (SELECT $1 AS json_data)', 'WITH pgrst_payload AS (SELECT $1::json AS json_data)');\n\n        -- Create a prepared statement for the given query\n        deallocate all;\n        execute format('prepare %I as %s', prepared_statement_name, query);\n\n        -- Detect how many arguments are present in the prepared statement\n        n_args = (\n            select\n                coalesce(array_length(parameter_types, 1), 0)\n            from\n                pg_prepared_statements\n            where\n                name = prepared_statement_name\n            limit\n                1\n        );\n\n        -- Create a SQL statement that can be executed to collect the explain plan\n        explain_plan_statement = format(\n            'set local plan_cache_mode = force_generic_plan; explain (format json) execute %I%s',\n            --'explain (format json) execute %I%s',\n            prepared_statement_name,\n            case\n                when n_args = 0 then ''\n                else format(\n                    '(%s)', array_to_string(array_fill('null'::text, array[n_args]), ',')\n                )\n            end\n        );\n\n        -- Store the query plan before any new indexes\n        execute explain_plan_statement into plan_initial;\n\n        -- Create possible indexes\n        for rec in (\n            with extension_regclass as (\n                select\n                    distinct objid as oid\n                from\n                    pg_catalog.pg_depend\n                where\n                    deptype = 'e'\n            )\n            select\n                pc.relnamespace::regnamespace::text as schema_name,\n                pc.relname as table_name,\n                pa.attname as column_name,\n                format(\n                    'select %I.hypopg_create_index($i$create index on %I.%I(%I)$i$)',\n                    hypopg_schema_name,\n                    pc.relnamespace::regnamespace::text,\n                    pc.relname,\n                    pa.attname\n                ) hypopg_statement\n            from\n                pg_catalog.pg_class pc\n                join pg_catalog.pg_attribute pa\n                    on pc.oid = pa.attrelid\n                left join extension_regclass er\n                    on pc.oid = er.oid\n                left join pg_catalog.pg_index pi\n                    on pc.oid = pi.indrelid\n                    and (select array_agg(x) from unnest(pi.indkey) v(x)) = array[pa.attnum]\n                    and pi.indexprs is null -- ignore expression indexes\n                    and pi.indpred is null -- ignore partial indexes\n            where\n                pc.relnamespace::regnamespace::text not in ( -- ignore schema list\n                    'pg_catalog', 'pg_toast', 'information_schema'\n                )\n                and er.oid is null -- ignore entities owned by extensions\n                and pc.relkind in ('r', 'm') -- regular tables, and materialized views\n                and pc.relpersistence = 'p' -- permanent tables (not unlogged or temporary)\n                and pa.attnum > 0\n                and not pa.attisdropped\n                and pi.indrelid is null\n                and pa.atttypid in (20,16,1082,1184,1114,701,23,21,700,1083,2950,1700,25,18,1042,1043)\n            )\n            loop\n                -- Create the hypothetical index\n                execute rec.hypopg_statement;\n            end loop;\n\n        /*\n        for rec in select * from hypopg()\n            loop\n                raise notice '%', rec;\n            end loop;\n        */\n\n        -- Create a prepared statement for the given query\n        -- The original prepared statement MUST be dropped because its plan is cached\n        execute format('deallocate %I', prepared_statement_name);\n        execute format('prepare %I as %s', prepared_statement_name, query);\n\n        -- Store the query plan after new indexes\n        execute explain_plan_statement into plan_final;\n\n        --raise notice '%', plan_final;\n\n        -- Idenfity referenced indexes in new plan\n        execute format(\n            'select\n                coalesce(array_agg(hypopg_get_indexdef(indexrelid) order by indrelid, indkey::text), $i${}$i$::text[])\n            from\n                %I.hypopg()\n            where\n                %s ilike ($i$%%$i$ || indexname || $i$%%$i$)\n            ',\n            hypopg_schema_name,\n            quote_literal(plan_final)::text\n        ) into statements;\n\n        -- Reset all hypothetical indexes\n        perform hypopg_reset();\n\n        -- Reset prepared statements\n        deallocate all;\n\n        return query values (\n            (plan_initial -> 0 -> 'Plan' -> 'Startup Cost'),\n            (plan_final -> 0 -> 'Plan' -> 'Startup Cost'),\n            (plan_initial -> 0 -> 'Plan' -> 'Total Cost'),\n            (plan_final -> 0 -> 'Plan' -> 'Total Cost'),\n            statements::text[],\n            array[]::text[]\n        );\n        return;\n\n    exception when others then\n        get stacked diagnostics error_message = MESSAGE_TEXT;\n\n        return query values (\n            null::jsonb,\n            null::jsonb,\n            null::jsonb,\n            null::jsonb,\n            array[]::text[],\n            array[error_message]::text[]\n        );\n        return;\n    end;\n\nend;\n$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pg_stat_statements",
    "args": "showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone)\n RETURNS SETOF record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_1_11$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pg_stat_statements_info",
    "args": "OUT dealloc bigint, OUT stats_reset timestamp with time zone",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone)\n RETURNS record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_info$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pg_stat_statements_reset",
    "args": "userid oid, dbid oid, queryid bigint, minmax_only boolean",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_reset(userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0, minmax_only boolean DEFAULT false)\n RETURNS timestamp with time zone\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_reset_1_11$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_armor_headers",
    "args": "text, OUT key text, OUT value text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text)\n RETURNS SETOF record\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_armor_headers$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_key_id",
    "args": "bytea",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_key_id(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_key_id_w$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_decrypt",
    "args": "bytea, bytea",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_decrypt",
    "args": "bytea, bytea, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_decrypt",
    "args": "bytea, bytea, text, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_decrypt_bytea",
    "args": "bytea, bytea",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_decrypt_bytea",
    "args": "bytea, bytea, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_decrypt_bytea",
    "args": "bytea, bytea, text, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_encrypt",
    "args": "text, bytea",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_encrypt",
    "args": "text, bytea, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_encrypt_bytea",
    "args": "bytea, bytea",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_encrypt_bytea",
    "args": "bytea, bytea, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_sym_decrypt",
    "args": "bytea, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_sym_decrypt",
    "args": "bytea, text, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_sym_decrypt_bytea",
    "args": "bytea, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_sym_decrypt_bytea",
    "args": "bytea, text, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_sym_encrypt",
    "args": "text, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_sym_encrypt",
    "args": "text, text, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_sym_encrypt_bytea",
    "args": "bytea, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_sym_encrypt_bytea",
    "args": "bytea, text, text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgrst_ddl_watch",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  cmd record;\nBEGIN\n  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()\n  LOOP\n    IF cmd.command_tag IN (\n      'CREATE SCHEMA', 'ALTER SCHEMA'\n    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'\n    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'\n    , 'CREATE VIEW', 'ALTER VIEW'\n    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'\n    , 'CREATE FUNCTION', 'ALTER FUNCTION'\n    , 'CREATE TRIGGER'\n    , 'CREATE TYPE', 'ALTER TYPE'\n    , 'CREATE RULE'\n    , 'COMMENT'\n    )\n    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp\n    AND cmd.schema_name is distinct from 'pg_temp'\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgrst_drop_watch",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  obj record;\nBEGIN\n  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n  LOOP\n    IF obj.object_type IN (\n      'schema'\n    , 'table'\n    , 'foreign table'\n    , 'view'\n    , 'materialized view'\n    , 'function'\n    , 'trigger'\n    , 'type'\n    , 'rule'\n    )\n    AND obj.is_temporary IS false -- no pg_temp objects\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "set_graphql_placeholder",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\n    DECLARE\n    graphql_is_dropped bool;\n    BEGIN\n    graphql_is_dropped = (\n        SELECT ev.schema_name = 'graphql_public'\n        FROM pg_event_trigger_dropped_objects() AS ev\n        WHERE ev.schema_name = 'graphql_public'\n    );\n\n    IF graphql_is_dropped\n    THEN\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language plpgsql\n        as $$\n            DECLARE\n                server_version float;\n            BEGIN\n                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);\n\n                IF server_version >= 14 THEN\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql extension is not enabled.'\n                            )\n                        )\n                    );\n                ELSE\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'\n                            )\n                        )\n                    );\n                END IF;\n            END;\n        $$;\n    END IF;\n\n    END;\n$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_generate_v1",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_generate_v1mc",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1mc()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1mc$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_generate_v3",
    "args": "namespace uuid, name text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v3(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v3$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_generate_v4",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v4()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v4$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_generate_v5",
    "args": "namespace uuid, name text",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v5(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v5$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_nil",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.uuid_nil()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_nil$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_ns_dns",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_dns()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_dns$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_ns_oid",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_oid()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_oid$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_ns_url",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_url()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_url$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_ns_x500",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_x500()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_x500$function$\n"
  },
  {
    "schema_name": "graphql",
    "function_name": "_internal_resolve",
    "args": "query text, variables jsonb, \"operationName\" text, extensions jsonb",
    "function_code": "CREATE OR REPLACE FUNCTION graphql._internal_resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE c\nAS '$libdir/pg_graphql', $function$resolve_wrapper$function$\n"
  },
  {
    "schema_name": "graphql",
    "function_name": "comment_directive",
    "args": "comment_ text",
    "function_code": "CREATE OR REPLACE FUNCTION graphql.comment_directive(comment_ text)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    comment on column public.account.name is '@graphql.name: myField'\n    */\n    select\n        coalesce(\n            (\n                regexp_match(\n                    comment_,\n                    '@graphql\\((.+)\\)'\n                )\n            )[1]::jsonb,\n            jsonb_build_object()\n        )\n$function$\n"
  },
  {
    "schema_name": "graphql",
    "function_name": "exception",
    "args": "message text",
    "function_code": "CREATE OR REPLACE FUNCTION graphql.exception(message text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nbegin\n    raise exception using errcode='22000', message=message;\nend;\n$function$\n"
  },
  {
    "schema_name": "graphql",
    "function_name": "get_schema_version",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION graphql.get_schema_version()\n RETURNS integer\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n    select last_value from graphql.seq_schema_version;\n$function$\n"
  },
  {
    "schema_name": "graphql",
    "function_name": "increment_schema_version",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION graphql.increment_schema_version()\n RETURNS event_trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nbegin\n    perform pg_catalog.nextval('graphql.seq_schema_version');\nend;\n$function$\n"
  },
  {
    "schema_name": "graphql",
    "function_name": "resolve",
    "args": "query text, variables jsonb, \"operationName\" text, extensions jsonb",
    "function_code": "CREATE OR REPLACE FUNCTION graphql.resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\ndeclare\n    res jsonb;\n    message_text text;\nbegin\n  begin\n    select graphql._internal_resolve(\"query\" := \"query\",\n                                     \"variables\" := \"variables\",\n                                     \"operationName\" := \"operationName\",\n                                     \"extensions\" := \"extensions\") into res;\n    return res;\n  exception\n    when others then\n    get stacked diagnostics message_text = message_text;\n    return\n    jsonb_build_object('data', null,\n                       'errors', jsonb_build_array(jsonb_build_object('message', message_text)));\n  end;\nend;\n$function$\n"
  },
  {
    "schema_name": "graphql_public",
    "function_name": "graphql",
    "args": "\"operationName\" text, query text, variables jsonb, extensions jsonb",
    "function_code": "CREATE OR REPLACE FUNCTION graphql_public.graphql(\"operationName\" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE sql\nAS $function$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $function$\n"
  },
  {
    "schema_name": "pgbouncer",
    "function_name": "get_auth",
    "args": "p_usename text",
    "function_code": "CREATE OR REPLACE FUNCTION pgbouncer.get_auth(p_usename text)\n RETURNS TABLE(username text, password text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\n  BEGIN\n      RAISE DEBUG 'PgBouncer auth request: %', p_usename;\n\n      RETURN QUERY\n      SELECT\n          rolname::text,\n          CASE WHEN rolvaliduntil < now()\n              THEN null\n              ELSE rolpassword::text\n          END\n      FROM pg_authid\n      WHERE rolname=$1 and rolcanlogin;\n  END;\n  $function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "_current_actor_id",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public._current_actor_id()\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_user uuid;\r\n  v_actor uuid;\r\nBEGIN\r\n  BEGIN\r\n    v_user := NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_user := NULL;\r\n  END;\r\n\r\n  IF v_user IS NULL THEN\r\n    RETURN NULL;\r\n  END IF;\r\n\r\n  -- Only return the id if a profiles row exists to satisfy FK\r\n  SELECT id INTO v_actor FROM public.profiles WHERE id = v_user;\r\n  RETURN v_actor; -- may be NULL (which keeps the audit insert valid)\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "_rebuild_stats_after_log",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public._rebuild_stats_after_log()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  PERFORM public.rebuild_player_match_stats(COALESCE(NEW.match_id, OLD.match_id));\r\n  RETURN COALESCE(NEW, OLD);\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "apply_match_log_delta",
    "args": "p_match_id uuid, p_team_id uuid, p_actor_id uuid, p_secondary_actor_id uuid, p_event_type_id smallint, p_direction integer",
    "function_code": "CREATE OR REPLACE FUNCTION public.apply_match_log_delta(p_match_id uuid, p_team_id uuid, p_actor_id uuid, p_secondary_actor_id uuid, p_event_type_id smallint, p_direction integer)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  v_code text;\r\n  v_dir integer := case when p_direction >= 0 then 1 else -1 end;\r\nbegin\r\n  if p_event_type_id is null or v_dir = 0 then\r\n    return;\r\n  end if;\r\n\r\n  select lower(code)\r\n    into v_code\r\n  from public.match_events\r\n  where id = p_event_type_id;\r\n\r\n  if v_code is null then\r\n    return;\r\n  end if;\r\n\r\n  if v_code = 'score' then\r\n    perform public.apply_player_stat_delta(p_match_id, p_actor_id, p_team_id, v_dir, 0, 0, 0);\r\n    if p_secondary_actor_id is not null then\r\n      perform public.apply_player_stat_delta(p_match_id, p_secondary_actor_id, p_team_id, 0, v_dir, 0, 0);\r\n    end if;\r\n  elsif v_code = 'callahan' then\r\n    perform public.apply_player_stat_delta(p_match_id, p_actor_id, p_team_id, v_dir, 0, v_dir, 0);\r\n    if p_secondary_actor_id is not null then\r\n      perform public.apply_player_stat_delta(p_match_id, p_secondary_actor_id, p_team_id, 0, v_dir, 0, 0);\r\n    end if;\r\n  elsif v_code = 'turnover' then\r\n    perform public.apply_player_stat_delta(p_match_id, p_actor_id, p_team_id, 0, 0, 0, v_dir);\r\n  elsif v_code = 'block' then\r\n    perform public.apply_player_stat_delta(p_match_id, p_actor_id, p_team_id, 0, 0, v_dir, 0);\r\n  end if;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "apply_player_stat_delta",
    "args": "p_match_id uuid, p_player_id uuid, p_team_hint uuid, p_goal_delta integer, p_assist_delta integer, p_block_delta integer, p_turnover_delta integer",
    "function_code": "CREATE OR REPLACE FUNCTION public.apply_player_stat_delta(p_match_id uuid, p_player_id uuid, p_team_hint uuid, p_goal_delta integer DEFAULT 0, p_assist_delta integer DEFAULT 0, p_block_delta integer DEFAULT 0, p_turnover_delta integer DEFAULT 0)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  v_goal_delta integer := coalesce(p_goal_delta, 0);\r\n  v_assist_delta integer := coalesce(p_assist_delta, 0);\r\n  v_block_delta integer := coalesce(p_block_delta, 0);\r\n  v_turnover_delta integer := coalesce(p_turnover_delta, 0);\r\n  v_team_id uuid;\r\n  v_matches_delta integer := 0;\r\n  v_had_row boolean;\r\n  v_after player_match_stats%rowtype;\r\nbegin\r\n  if p_player_id is null then\r\n    return;\r\n  end if;\r\n\r\n  if v_goal_delta = 0 and v_assist_delta = 0 and v_block_delta = 0 and v_turnover_delta = 0 then\r\n    return;\r\n  end if;\r\n\r\n  select exists (\r\n    select 1\r\n    from public.player_match_stats\r\n    where match_id = p_match_id\r\n      and player_id = p_player_id\r\n  ) into v_had_row\r\n  for share;\r\n\r\n  v_team_id := public.resolve_match_player_team(p_match_id, p_player_id, p_team_hint);\r\n\r\n  insert into public.player_match_stats (\r\n    match_id,\r\n    player_id,\r\n    team_id,\r\n    goals,\r\n    assists,\r\n    blocks,\r\n    turnovers\r\n  )\r\n  values (\r\n    p_match_id,\r\n    p_player_id,\r\n    v_team_id,\r\n    greatest(v_goal_delta, 0),\r\n    greatest(v_assist_delta, 0),\r\n    greatest(v_block_delta, 0),\r\n    greatest(v_turnover_delta, 0)\r\n  )\r\n  on conflict (match_id, player_id) do update\r\n    set team_id   = coalesce(excluded.team_id, public.player_match_stats.team_id),\r\n        goals     = greatest(public.player_match_stats.goals     + excluded.goals,     0),\r\n        assists   = greatest(public.player_match_stats.assists   + excluded.assists,   0),\r\n        blocks    = greatest(public.player_match_stats.blocks    + excluded.blocks,    0),\r\n        turnovers = greatest(public.player_match_stats.turnovers + excluded.turnovers, 0),\r\n        updated_at = now()\r\n  returning * into v_after;\r\n\r\n  if v_after.goals = 0\r\n     and v_after.assists = 0\r\n     and v_after.blocks = 0\r\n     and v_after.turnovers = 0 then\r\n    delete from public.player_match_stats\r\n    where match_id = p_match_id\r\n      and player_id = p_player_id;\r\n  end if;\r\n\r\n  if not v_had_row and (v_after.goals > 0 or v_after.assists > 0 or v_after.blocks > 0 or v_after.turnovers > 0) then\r\n    v_matches_delta := 1;\r\n  elsif v_had_row and v_after.goals = 0 and v_after.assists = 0 and v_after.blocks = 0 and v_after.turnovers = 0 then\r\n    v_matches_delta := -1;\r\n  end if;\r\n\r\n  insert into public.player_statistics (player_id, matches, goals, assists, blocks, turnovers)\r\n  values (\r\n    p_player_id,\r\n    v_matches_delta,\r\n    v_goal_delta,\r\n    v_assist_delta,\r\n    v_block_delta,\r\n    v_turnover_delta\r\n  )\r\n  on conflict (player_id) do update\r\n    set matches   = greatest(public.player_statistics.matches   + excluded.matches,   0),\r\n        goals     = greatest(public.player_statistics.goals     + excluded.goals,     0),\r\n        assists   = greatest(public.player_statistics.assists   + excluded.assists,   0),\r\n        blocks    = greatest(public.player_statistics.blocks    + excluded.blocks,    0),\r\n        turnovers = greatest(public.player_statistics.turnovers + excluded.turnovers, 0);\r\n\r\n  delete from public.player_statistics\r\n  where player_id = p_player_id\r\n    and matches = 0\r\n    and goals = 0\r\n    and assists = 0\r\n    and blocks = 0\r\n    and turnovers = 0;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "assign_default_viewer_role",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public.assign_default_viewer_role()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\ndeclare\r\n  v_user_role_id smallint;\r\nbegin\r\n  select r.id::smallint\r\n    into v_user_role_id\r\n  from public.roles r\r\n  where lower(r.name) = 'user'\r\n    and r.scope = 'global'\r\n  limit 1;\r\n\r\n  if v_user_role_id is null then\r\n    raise exception 'Global role \"user\" not found in public.roles';\r\n  end if;\r\n\r\n  insert into public.user_roles (user_id, role_id, granted_by)\r\n  values (new.id, v_user_role_id, new.id)\r\n  on conflict (user_id, role_id) do nothing;\r\n\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "audit_row",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "can_write_match_logs",
    "args": "_match_id uuid",
    "function_code": "CREATE OR REPLACE FUNCTION public.can_write_match_logs(_match_id uuid)\n RETURNS boolean\n LANGUAGE sql\n STABLE\nAS $function$\r\n  SELECT\r\n    -- allowed roles\r\n    EXISTS (\r\n      SELECT 1\r\n      FROM public.profiles pr\r\n      JOIN public.roles r ON r.id = pr.role_id\r\n      WHERE pr.id = public.uid()\r\n        AND r.name IN ('admin','td','scorekeeper')\r\n    )\r\n    -- and match status is writable\r\n    AND EXISTS (\r\n      SELECT 1\r\n      FROM public.matches m\r\n      WHERE m.id = _match_id\r\n        AND m.status IN ('scheduled','live','halftime')\r\n    );\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "enforce_event_user_roles_event_scope",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public.enforce_event_user_roles_event_scope()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  v_scope text;\r\nbegin\r\n  select scope\r\n    into v_scope\r\n  from public.roles\r\n  where id = new.role_id;\r\n\r\n  if v_scope is null then\r\n    raise exception 'Role % does not exist.', new.role_id;\r\n  end if;\r\n\r\n  if v_scope <> 'event' then\r\n    raise exception\r\n      'Role % has scope \"%\". Only event-scoped roles are allowed in event_user_roles.',\r\n      new.role_id,\r\n      v_scope;\r\n  end if;\r\n\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "enforce_user_roles_global_scope",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public.enforce_user_roles_global_scope()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  v_scope text;\r\nbegin\r\n  select scope\r\n    into v_scope\r\n  from public.roles\r\n  where id = new.role_id;\r\n\r\n  if v_scope is null then\r\n    raise exception 'Role % does not exist.', new.role_id;\r\n  end if;\r\n\r\n  if v_scope <> 'global' then\r\n    raise exception\r\n      'Role % has scope \"%\". Only global roles are allowed in user_roles.',\r\n      new.role_id,\r\n      v_scope;\r\n  end if;\r\n\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "enqueue_live_event_from_log",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public.enqueue_live_event_from_log()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$declare\r\n  event_code text;\r\n  payload jsonb;\r\n  match_rec record;\r\n  match_label text;\r\n  team_label text;\r\n  player_label text;\r\n  secondary_player_label text;\r\n  human_event text;\r\nbegin\r\n  select code into event_code\r\n  from public.match_events\r\n  where id = new.event_type_id;\r\n\r\n  if event_code is null then\r\n    return new;\r\n  end if;\r\n\r\n  select\r\n    m.id,\r\n    m.event_id,\r\n    m.division_id,\r\n    m.team_a,\r\n    m.team_b,\r\n    m.start_time,\r\n    ta.name as team_a_name,\r\n    tb.name as team_b_name,\r\n    ev.name as event_name,\r\n    d.name as division_name\r\n  into match_rec\r\n  from public.matches m\r\n  left join public.teams ta on ta.id = m.team_a\r\n  left join public.teams tb on tb.id = m.team_b\r\n  left join public.events ev on ev.id = m.event_id\r\n  left join public.divisions d on d.id = m.division_id\r\n  where m.id = new.match_id;\r\n\r\n  match_label := coalesce(nullif(match_rec.team_a_name, ''), 'Team A')\r\n    || ' vs '\r\n    || coalesce(nullif(match_rec.team_b_name, ''), 'Team B');\r\n\r\n  if match_label is null or match_label = ' vs ' then\r\n    match_label := coalesce(new.match_id::text, 'Match');\r\n  end if;\r\n\r\n  if new.team_id is not null then\r\n    if new.team_id = match_rec.team_a then\r\n      team_label := coalesce(nullif(match_rec.team_a_name, ''), 'Team A');\r\n    elsif new.team_id = match_rec.team_b then\r\n      team_label := coalesce(nullif(match_rec.team_b_name, ''), 'Team B');\r\n    else\r\n      select name into team_label\r\n      from public.teams\r\n      where id = new.team_id;\r\n    end if;\r\n  end if;\r\n\r\n  if new.actor_id is not null then\r\n    select name into player_label\r\n    from public.player\r\n    where id = new.actor_id;\r\n  end if;\r\n\r\n  if new.secondary_actor_id is not null then\r\n    select name into secondary_player_label\r\n    from public.player\r\n    where id = new.secondary_actor_id;\r\n  end if;\r\n\r\n  human_event := initcap(replace(event_code, '_', ' '));\r\n\r\n  payload := jsonb_build_object(\r\n    'log_id', new.id,\r\n    'match_id', new.match_id,\r\n    'event_id', match_rec.event_id,\r\n    'division_id', match_rec.division_id,\r\n    'team_id', new.team_id,\r\n    'team_name', team_label,\r\n    'player_id', new.actor_id,\r\n    'player_name', player_label,\r\n    'secondary_player_id', new.secondary_actor_id,\r\n    'secondary_player_name', secondary_player_label,\r\n    'abba_line', new.abba_line,\r\n    'match_start_time', match_rec.start_time,\r\n    'match_name', match_label,\r\n    'division_name', match_rec.division_name,\r\n    'target_name', coalesce(team_label, match_label),\r\n    'title', human_event || ' - ' || coalesce(team_label, match_label),\r\n    'body', format('%s for %s', human_event, coalesce(team_label, match_label)),\r\n    'url', format('/matches/%s', new.match_id)\r\n  );\r\n\r\n  insert into public.live_events (match_id, event_type, data)\r\n  values (new.match_id, event_code, payload);\r\n\r\n  return new;\r\nend;$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "fetch_pending_live_event_payloads",
    "args": "batch_size integer",
    "function_code": "CREATE OR REPLACE FUNCTION public.fetch_pending_live_event_payloads(batch_size integer DEFAULT 50)\n RETURNS TABLE(id uuid, match_id uuid, event_type text, data jsonb, created_at timestamp with time zone, push_subscribers jsonb)\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nwith pending as (\r\n  select *\r\n  from public.live_events\r\n  where sent = false\r\n  order by created_at\r\n  limit greatest(1, coalesce(batch_size, 50))\r\n),\r\ntargets as (\r\n  select\r\n    e.id as event_id,\r\n    s.profile_id,\r\n    lower(s.target_type::text) as target_type,\r\n    s.target_id,\r\n    s.topics\r\n  from pending e\r\n  join public.subscriptions s\r\n    on (\r\n      (lower(s.target_type::text) = 'match'    and s.target_id = e.match_id)\r\n      or (lower(s.target_type::text) = 'team'  and s.target_id = (e.data ->> 'team_id')::uuid)\r\n      or (lower(s.target_type::text) = 'player' and s.target_id = (e.data ->> 'player_id')::uuid)\r\n      or (lower(s.target_type::text) = 'event'   and s.target_id = (e.data ->> 'event_id')::uuid)\r\n      or (lower(s.target_type::text) = 'division' and s.target_id = (e.data ->> 'division_id')::uuid)\r\n    )\r\n    and (\r\n      cardinality(s.topics) = 0\r\n      or lower(e.event_type) = any (\r\n        select lower(value) from unnest(s.topics) as value\r\n      )\r\n    )\r\n),\r\nendpoints as (\r\n  select\r\n    t.event_id,\r\n    jsonb_build_object(\r\n      'profile_id', ps.profile_id,\r\n      'endpoint', ps.endpoint,\r\n      'p256dh', ps.p256dh_key,\r\n      'auth', ps.auth_key\r\n    ) as endpoint\r\n  from targets t\r\n  join public.push_subscriptions ps\r\n    on ps.profile_id = t.profile_id\r\n)\r\nselect\r\n  e.id,\r\n  e.match_id,\r\n  e.event_type,\r\n  e.data,\r\n  e.created_at,\r\n  jsonb_agg(distinct ep.endpoint) filter (where ep.endpoint is not null) as push_subscribers\r\nfrom pending e\r\nleft join endpoints ep\r\n  on ep.event_id = e.id\r\ngroup by e.id, e.match_id, e.event_type, e.data, e.created_at;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "gen_jersey_3digit",
    "args": "p_event text, p_team text, p_player text",
    "function_code": "CREATE OR REPLACE FUNCTION public.gen_jersey_3digit(p_event text, p_team text, p_player text)\n RETURNS integer\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\r\n  SELECT 100 + ( ('x' || substr(md5(coalesce(p_event,'') || ':' || coalesce(p_team,'') || ':' || coalesce(p_player,'')),1,8))::bit(32)::int % 900 );\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "gen_jersey_3digit",
    "args": "p_event uuid, p_team uuid, p_player uuid",
    "function_code": "CREATE OR REPLACE FUNCTION public.gen_jersey_3digit(p_event uuid, p_team uuid, p_player uuid)\n RETURNS integer\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\r\n  SELECT 100 + (\r\n    ( 'x' || substr(md5(p_event::text || ':' || p_team::text || ':' || p_player::text), 1, 8) )::bit(32)::int\r\n    % 900\r\n  );\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_scoreboard_snapshot",
    "args": "p_match_id uuid",
    "function_code": "CREATE OR REPLACE FUNCTION public.get_scoreboard_snapshot(p_match_id uuid)\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\r\n  select to_jsonb(s)\r\n  from public.scoreboard_match_snapshots s\r\n  where s.match_id = p_match_id;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "grant_role",
    "args": "p_user_id uuid, p_role_name text",
    "function_code": "CREATE OR REPLACE FUNCTION public.grant_role(p_user_id uuid, p_role_name text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n    v_role_id smallint;\r\nBEGIN\r\n    SELECT id INTO v_role_id FROM public.roles WHERE name = p_role_name;\r\n    IF v_role_id IS NULL THEN\r\n        RAISE EXCEPTION 'Role % not found', p_role_name;\r\n    END IF;\r\n\r\n    INSERT INTO public.user_roles (user_id, role_id, granted_by)\r\n    VALUES (p_user_id, v_role_id, auth.uid())\r\n    ON CONFLICT (user_id, role_id) DO NOTHING;\r\nEND;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "grant_role",
    "args": "p_user_id uuid, p_role_name text, p_granted_by uuid",
    "function_code": "CREATE OR REPLACE FUNCTION public.grant_role(p_user_id uuid, p_role_name text, p_granted_by uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_role_id smallint;\r\n  v_actor uuid := COALESCE(p_granted_by, auth.uid());\r\nBEGIN\r\n  IF p_user_id IS NULL THEN\r\n    RAISE EXCEPTION 'User id is required';\r\n  END IF;\r\n\r\n  SELECT id INTO v_role_id FROM public.roles WHERE name = p_role_name;\r\n  IF v_role_id IS NULL THEN\r\n    RAISE EXCEPTION 'Unknown role %', p_role_name;\r\n  END IF;\r\n\r\n  INSERT INTO public.user_roles (user_id, role_id, granted_by)\r\n  VALUES (p_user_id, v_role_id, v_actor)\r\n  ON CONFLICT (user_id, role_id) DO UPDATE\r\n    SET granted_by = EXCLUDED.granted_by;\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "handle_match_log_player_stats",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public.handle_match_log_player_stats()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_match_id uuid := COALESCE(NEW.match_id, OLD.match_id);\r\nBEGIN\r\n  IF v_match_id IS NULL THEN\r\n    RETURN COALESCE(NEW, OLD);\r\n  END IF;\r\n  PERFORM public.rebuild_player_match_stats(v_match_id);\r\n  RETURN COALESCE(NEW, OLD);\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "handle_new_user",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\ndeclare\r\n  viewer_role_id smallint;\r\nbegin\r\n  -- create profile\r\n  insert into public.profiles (id, email, full_name)\r\n  values (\r\n    new.id,\r\n    new.email,\r\n    coalesce(new.raw_user_meta_data->>'full_name', new.email)\r\n  )\r\n  on conflict (id) do nothing;\r\n\r\n  -- resolve viewer role id by name\r\n  select id into viewer_role_id\r\n  from public.roles\r\n  where name = 'viewer'\r\n  limit 1;\r\n\r\n  -- assign default viewer role if it exists\r\n  if viewer_role_id is not null then\r\n    insert into public.user_roles (user_id, role_id, granted_by)\r\n    values (new.id, viewer_role_id, new.id)\r\n    on conflict (user_id, role_id) do nothing;\r\n  end if;\r\n\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "has_event_permission",
    "args": "permission_key text, target_event_id uuid",
    "function_code": "CREATE OR REPLACE FUNCTION public.has_event_permission(permission_key text, target_event_id uuid)\n RETURNS boolean\n LANGUAGE sql\n STABLE SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\n  select\r\n    -- Global override path\r\n    public.has_role('admin')\r\n    or public.has_role('administrator')\r\n    or public.has_permission(permission_key)\r\n    -- Event-scoped permission path\r\n    or exists (\r\n      select 1\r\n      from public.event_user_roles eur\r\n      join public.roles r\r\n        on r.id = eur.role_id\r\n       and r.scope = 'event'\r\n      join public.role_permissions rp\r\n        on rp.role_id = r.id\r\n      join public.permissions p\r\n        on p.id = rp.permission_id\r\n      where eur.user_id = auth.uid()\r\n        and eur.event_id = target_event_id\r\n        and lower(p.key) = lower(permission_key)\r\n    );\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "has_permission",
    "args": "permission_key text",
    "function_code": "CREATE OR REPLACE FUNCTION public.has_permission(permission_key text)\n RETURNS boolean\n LANGUAGE sql\n STABLE SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\n  select exists (\r\n    select 1\r\n    from public.user_roles ur\r\n    join public.roles r\r\n      on r.id = ur.role_id\r\n     and r.scope = 'global'\r\n    join public.role_permissions rp\r\n      on rp.role_id = r.id\r\n    join public.permissions p\r\n      on p.id = rp.permission_id\r\n    where ur.user_id = auth.uid()\r\n      and lower(p.key) = lower(permission_key)\r\n  );\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "has_role",
    "args": "target_role text",
    "function_code": "CREATE OR REPLACE FUNCTION public.has_role(target_role text)\n RETURNS boolean\n LANGUAGE sql\n STABLE SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\n  select exists (\r\n    select 1\r\n    from public.user_roles ur\r\n    join public.roles r on r.id = ur.role_id\r\n    where ur.user_id = auth.uid()\r\n      and r.scope = 'global'\r\n      and lower(r.name) = lower(target_role)\r\n  );\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "players_tsv_trigger",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public.players_tsv_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.search :=\r\n    to_tsvector('simple',\r\n      coalesce(NEW.name,'') || ' ' || coalesce(NEW.gender_code,'')\r\n    );\r\n  RETURN NEW;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "rebuild_player_match_stats",
    "args": "target_match_id uuid",
    "function_code": "CREATE OR REPLACE FUNCTION public.rebuild_player_match_stats(target_match_id uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF target_match_id IS NULL THEN\n    RAISE EXCEPTION 'match_id is required';\n  END IF;\n\n  -- serialize rebuilds for the same match_id to avoid concurrent races\n  PERFORM pg_advisory_xact_lock(('x' || substr(md5(target_match_id::text),1,15))::bit(64)::bigint);\n\n  -- upsert aggregated stats\n  WITH goal_rows AS (\n    SELECT ml.match_id, ml.team_id, ml.actor_id AS player_id\n    FROM public.match_logs ml\n    JOIN public.match_events me ON me.id = ml.event_type_id\n    WHERE ml.match_id = target_match_id\n      AND ml.actor_id IS NOT NULL\n      AND me.code IN ('score', 'calahan')\n  ),\n  assist_rows AS (\n    SELECT ml.match_id, ml.team_id, ml.secondary_actor_id AS player_id\n    FROM public.match_logs ml\n    JOIN public.match_events me ON me.id = ml.event_type_id\n    WHERE ml.match_id = target_match_id\n      AND ml.secondary_actor_id IS NOT NULL\n      AND me.code = 'score'\n  ),\n  turnover_rows AS (\n    SELECT ml.match_id, ml.team_id, ml.actor_id AS player_id\n    FROM public.match_logs ml\n    JOIN public.match_events me ON me.id = ml.event_type_id\n    WHERE ml.match_id = target_match_id\n      AND ml.actor_id IS NOT NULL\n      AND me.code = 'turnover'\n  ),\n  aggregated AS (\n    SELECT\n      match_id,\n      player_id,\n      team_id,\n      COUNT(*) FILTER (WHERE src = 'goal') AS goals,\n      COUNT(*) FILTER (WHERE src = 'assist') AS assists,\n      0::int AS blocks,\n      COUNT(*) FILTER (WHERE src = 'turnover') AS turnovers\n    FROM (\n      SELECT match_id, team_id, player_id, 'goal'::text AS src FROM goal_rows\n      UNION ALL\n      SELECT match_id, team_id, player_id, 'assist' FROM assist_rows\n      UNION ALL\n      SELECT match_id, team_id, player_id, 'turnover' FROM turnover_rows\n    ) s\n    GROUP BY match_id, player_id, team_id\n  ),\n  upsert AS (\n    INSERT INTO public.player_match_stats (\n      match_id, player_id, team_id, goals, assists, blocks, turnovers, updated_at\n    )\n    SELECT match_id, player_id, team_id, goals, assists, blocks, turnovers, now()\n    FROM aggregated\n    ON CONFLICT (match_id, player_id) DO UPDATE\n    SET team_id = EXCLUDED.team_id,\n        goals = EXCLUDED.goals,\n        assists = EXCLUDED.assists,\n        blocks = EXCLUDED.blocks,\n        turnovers = EXCLUDED.turnovers,\n        updated_at = now()\n    RETURNING player_id\n  )\n  -- remove any stale rows for this match_id that are not present in the aggregated set\n  DELETE FROM public.player_match_stats pms\n  WHERE pms.match_id = target_match_id\n    AND NOT EXISTS (\n      SELECT 1 FROM aggregated a WHERE a.match_id = pms.match_id AND a.player_id = pms.player_id\n    );\n\nEND\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "recompute_player_gender",
    "args": "p_player_id uuid",
    "function_code": "CREATE OR REPLACE FUNCTION public.recompute_player_gender(p_player_id uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE g text;\r\nBEGIN\r\n  SELECT CASE\r\n           WHEN max((d.name ILIKE 'wom%')::int)=1 THEN 'W'\r\n           WHEN max((d.name ILIKE 'men%')::int)=1 THEN 'M'\r\n           ELSE NULL\r\n         END\r\n    INTO g\r\n  FROM public.team_roster tr\r\n  JOIN public.division_teams dt ON dt.team_id = tr.team_id\r\n  JOIN public.divisions d       ON d.id       = dt.division_id\r\n  WHERE tr.player_id = p_player_id;\r\n\r\n  IF g IS NOT NULL THEN\r\n    UPDATE public.player SET gender_code = g WHERE id = p_player_id;\r\n  END IF;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "register_scoreboard_device",
    "args": "p_device jsonb, p_targets jsonb",
    "function_code": "CREATE OR REPLACE FUNCTION public.register_scoreboard_device(p_device jsonb, p_targets jsonb DEFAULT '[]'::jsonb)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\ndeclare\r\n  v_profile uuid := auth.uid();\r\n  v_device_id uuid;\r\n  v_hardware text := nullif(p_device->>'hardware_id', '');\r\nbegin\r\n  if v_profile is null then\r\n    raise exception 'Authentication required.';\r\n  end if;\r\n  if v_hardware is null then\r\n    raise exception 'hardware_id is required.';\r\n  end if;\r\n\r\n  insert into public.scoreboard_devices as d (\r\n    profile_id,\r\n    device_label,\r\n    hardware_id,\r\n    metadata,\r\n    operator_name,\r\n    notes,\r\n    status,\r\n    registered_at\r\n  )\r\n  values (\r\n    v_profile,\r\n    coalesce(nullif(p_device->>'device_label', ''), 'Unnamed device'),\r\n    v_hardware,\r\n    coalesce(p_device->'metadata', '{}'::jsonb),\r\n    nullif(p_device->>'operator_name', ''),\r\n    nullif(p_device->>'notes', ''),\r\n    'registered',\r\n    coalesce((p_device->>'registered_at')::timestamptz, now())\r\n  )\r\n  on conflict (hardware_id)\r\n  do update set\r\n    device_label = excluded.device_label,\r\n    metadata = excluded.metadata,\r\n    operator_name = excluded.operator_name,\r\n    notes = excluded.notes,\r\n    registered_at = excluded.registered_at,\r\n    profile_id = v_profile,\r\n    status = 'registered',\r\n    updated_at = now()\r\n  returning id into v_device_id;\r\n\r\n  perform public.sync_scoreboard_device_subscriptions(v_device_id, p_targets);\r\n\r\n  return v_device_id;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "register_scoreboard_device",
    "args": "p_device_label text, p_hardware_id text, p_metadata jsonb, p_venue uuid, p_match uuid",
    "function_code": "CREATE OR REPLACE FUNCTION public.register_scoreboard_device(p_device_label text, p_hardware_id text, p_metadata jsonb DEFAULT '{}'::jsonb, p_venue uuid DEFAULT NULL::uuid, p_match uuid DEFAULT NULL::uuid)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\ndeclare\r\n  v_id uuid;\r\nbegin\r\n  insert into public.scoreboard_devices (\r\n    profile_id,\r\n    device_label,\r\n    hardware_id,\r\n    metadata,\r\n    venue_id,\r\n    match_id\r\n  )\r\n  values (\r\n    auth.uid(),\r\n    coalesce(nullif(trim(p_device_label), ''), 'Unnamed device'),\r\n    coalesce(nullif(trim(p_hardware_id), ''), gen_random_uuid()::text),\r\n    coalesce(p_metadata, '{}'::jsonb),\r\n    p_venue,\r\n    p_match\r\n  )\r\n  on conflict (profile_id, hardware_id) do update\r\n    set device_label = excluded.device_label,\r\n        metadata = excluded.metadata,\r\n        venue_id = excluded.venue_id,\r\n        match_id = excluded.match_id\r\n  returning id into v_id;\r\n\r\n  return v_id;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "resolve_match_player_team",
    "args": "p_match_id uuid, p_player_id uuid, p_hint uuid",
    "function_code": "CREATE OR REPLACE FUNCTION public.resolve_match_player_team(p_match_id uuid, p_player_id uuid, p_hint uuid)\n RETURNS uuid\n LANGUAGE sql\n STABLE\nAS $function$\r\n  select coalesce(\r\n    p_hint,\r\n    (\r\n      select tr.team_id\r\n      from public.team_roster tr\r\n      join public.matches m on m.id = p_match_id\r\n      where tr.player_id = p_player_id\r\n        and tr.event_id = m.event_id\r\n        and tr.team_id in (m.team_a, m.team_b)\r\n      order by tr.updated_at desc\r\n      limit 1\r\n    )\r\n  );\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "revoke_role",
    "args": "p_user_id uuid, p_role_name text",
    "function_code": "CREATE OR REPLACE FUNCTION public.revoke_role(p_user_id uuid, p_role_name text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_role_id smallint;\r\nBEGIN\r\n  IF p_user_id IS NULL THEN\r\n    RAISE EXCEPTION 'User id is required';\r\n  END IF;\r\n\r\n  SELECT id INTO v_role_id FROM public.roles WHERE name = p_role_name;\r\n  IF v_role_id IS NULL THEN\r\n    RAISE EXCEPTION 'Unknown role %', p_role_name;\r\n  END IF;\r\n\r\n  DELETE FROM public.user_roles\r\n  WHERE user_id = p_user_id\r\n    AND role_id = v_role_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "sync_scoreboard_device_subscriptions",
    "args": "p_device_id uuid, p_targets jsonb",
    "function_code": "CREATE OR REPLACE FUNCTION public.sync_scoreboard_device_subscriptions(p_device_id uuid, p_targets jsonb DEFAULT '[]'::jsonb)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\ndeclare\r\n  v_profile uuid := auth.uid();\r\nbegin\r\n  if v_profile is null then\r\n    raise exception 'Authentication required.';\r\n  end if;\r\n  if p_device_id is null then\r\n    raise exception 'Device id required.';\r\n  end if;\r\n\r\n  delete from public.scoreboard_device_subscriptions s\r\n  where s.device_id = p_device_id\r\n    and s.created_by = v_profile\r\n    and not exists (\r\n      select 1\r\n      from jsonb_array_elements(coalesce(p_targets, '[]'::jsonb)) elem\r\n      where elem ? 'target_type'\r\n        and elem ? 'target_id'\r\n        and (elem->>'target_type')::public.scoreboard_subscription_target = s.target_type\r\n        and nullif(elem->>'target_id', '')::uuid = s.target_id\r\n    );\r\n\r\n  insert into public.scoreboard_device_subscriptions as s (device_id, target_type, target_id, priority, created_by)\r\n  select\r\n    p_device_id,\r\n    (elem->>'target_type')::public.scoreboard_subscription_target,\r\n    nullif(elem->>'target_id', '')::uuid,\r\n    coalesce((elem->>'priority')::integer, 100),\r\n    v_profile\r\n  from jsonb_array_elements(coalesce(p_targets, '[]'::jsonb)) elem\r\n  where elem ? 'target_type'\r\n    and elem ? 'target_id'\r\n    and elem->>'target_type' in ('match', 'venue')\r\n    and nullif(elem->>'target_id', '') is not null\r\n  on conflict (device_id, target_type, target_id)\r\n  do update set\r\n    priority = excluded.priority,\r\n    updated_at = now(),\r\n    created_by = excluded.created_by;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "touch_scoreboard_device_subscriptions_updated_at",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public.touch_scoreboard_device_subscriptions_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  new.updated_at = now();\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "touch_scoreboard_device_updated_at",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public.touch_scoreboard_device_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  new.updated_at = now();\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "touch_scoreboard_devices_updated_at",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public.touch_scoreboard_devices_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  new.updated_at = now();\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "touch_scoreboard_match_snapshots",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public.touch_scoreboard_match_snapshots()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  new.updated_at = now();\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "touch_updated_at",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public.touch_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  new.updated_at = now();\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "trg_player_stats_from_match_logs",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public.trg_player_stats_from_match_logs()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  if TG_OP = 'INSERT' then\r\n    perform public.apply_match_log_delta(\r\n      NEW.match_id,\r\n      NEW.team_id,\r\n      NEW.actor_id,\r\n      NEW.secondary_actor_id,\r\n      NEW.event_type_id,\r\n      1\r\n    );\r\n    return NEW;\r\n  elsif TG_OP = 'DELETE' then\r\n    perform public.apply_match_log_delta(\r\n      OLD.match_id,\r\n      OLD.team_id,\r\n      OLD.actor_id,\r\n      OLD.secondary_actor_id,\r\n      OLD.event_type_id,\r\n      -1\r\n    );\r\n    return OLD;\r\n  elsif TG_OP = 'UPDATE' then\r\n    perform public.apply_match_log_delta(\r\n      OLD.match_id,\r\n      OLD.team_id,\r\n      OLD.actor_id,\r\n      OLD.secondary_actor_id,\r\n      OLD.event_type_id,\r\n      -1\r\n    );\r\n    perform public.apply_match_log_delta(\r\n      NEW.match_id,\r\n      NEW.team_id,\r\n      NEW.actor_id,\r\n      NEW.secondary_actor_id,\r\n      NEW.event_type_id,\r\n      1\r\n    );\r\n    return NEW;\r\n  end if;\r\n\r\n  return null;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "trg_roster_gender_sync",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public.trg_roster_gender_sync()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  PERFORM public.recompute_player_gender(\r\n    COALESCE(NEW.player_id, OLD.player_id)\r\n  );\r\n  RETURN COALESCE(NEW, OLD);\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "uid",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION public.uid()\n RETURNS uuid\n LANGUAGE sql\n STABLE\nAS $function$ SELECT NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid $function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "upsert_scoreboard_match_snapshot",
    "args": "p_match_id uuid, p_payload jsonb, p_last_log_id uuid",
    "function_code": "CREATE OR REPLACE FUNCTION public.upsert_scoreboard_match_snapshot(p_match_id uuid, p_payload jsonb, p_last_log_id uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nbegin\r\n  if p_match_id is null then\r\n    raise exception 'match_id is required';\r\n  end if;\r\n  if p_payload is null then\r\n    raise exception 'payload is required';\r\n  end if;\r\n\r\n  insert into public.scoreboard_match_snapshots (match_id, payload, last_log_id)\r\n  values (p_match_id, p_payload, p_last_log_id)\r\n  on conflict (match_id)\r\n  do update set\r\n    payload = excluded.payload,\r\n    last_log_id = coalesce(excluded.last_log_id, public.scoreboard_match_snapshots.last_log_id),\r\n    updated_at = now();\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "upsert_scoreboard_offset",
    "args": "p_device_id uuid, p_match_id uuid, p_last_log_id uuid, p_last_log_created_at timestamp with time zone, p_cached_snapshot jsonb",
    "function_code": "CREATE OR REPLACE FUNCTION public.upsert_scoreboard_offset(p_device_id uuid, p_match_id uuid, p_last_log_id uuid, p_last_log_created_at timestamp with time zone, p_cached_snapshot jsonb DEFAULT NULL::jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  insert into public.scoreboard_device_offsets as s (\r\n    device_id, match_id, last_log_id, last_log_created_at, cached_snapshot\r\n  )\r\n  values (p_device_id, p_match_id, p_last_log_id, p_last_log_created_at, p_cached_snapshot)\r\n  on conflict (device_id, match_id) do update\r\n    set last_log_id = excluded.last_log_id,\r\n        last_log_created_at = excluded.last_log_created_at,\r\n        cached_snapshot = coalesce(excluded.cached_snapshot, s.cached_snapshot),\r\n        updated_at = now();\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "apply_rls",
    "args": "wal jsonb, max_record_bytes integer",
    "function_code": "CREATE OR REPLACE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024))\n RETURNS SETOF realtime.wal_rls\n LANGUAGE plpgsql\nAS $function$\ndeclare\n-- Regclass of the table e.g. public.notes\nentity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;\n\n-- I, U, D, T: insert, update ...\naction realtime.action = (\n    case wal ->> 'action'\n        when 'I' then 'INSERT'\n        when 'U' then 'UPDATE'\n        when 'D' then 'DELETE'\n        else 'ERROR'\n    end\n);\n\n-- Is row level security enabled for the table\nis_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;\n\nsubscriptions realtime.subscription[] = array_agg(subs)\n    from\n        realtime.subscription subs\n    where\n        subs.entity = entity_\n        -- Filter by action early - only get subscriptions interested in this action\n        -- action_filter column can be: '*' (all), 'INSERT', 'UPDATE', or 'DELETE'\n        and (subs.action_filter = '*' or subs.action_filter = action::text);\n\n-- Subscription vars\nroles regrole[] = array_agg(distinct us.claims_role::text)\n    from\n        unnest(subscriptions) us;\n\nworking_role regrole;\nclaimed_role regrole;\nclaims jsonb;\n\nsubscription_id uuid;\nsubscription_has_access bool;\nvisible_to_subscription_ids uuid[] = '{}';\n\n-- structured info for wal's columns\ncolumns realtime.wal_column[];\n-- previous identity values for update/delete\nold_columns realtime.wal_column[];\n\nerror_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;\n\n-- Primary jsonb output for record\noutput jsonb;\n\nbegin\nperform set_config('role', null, true);\n\ncolumns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'columns') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nold_columns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'identity') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nfor working_role in select * from unnest(roles) loop\n\n    -- Update `is_selectable` for columns and old_columns\n    columns =\n        array_agg(\n            (\n                c.name,\n                c.type_name,\n                c.type_oid,\n                c.value,\n                c.is_pkey,\n                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n            )::realtime.wal_column\n        )\n        from\n            unnest(columns) c;\n\n    old_columns =\n            array_agg(\n                (\n                    c.name,\n                    c.type_name,\n                    c.type_oid,\n                    c.value,\n                    c.is_pkey,\n                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n                )::realtime.wal_column\n            )\n            from\n                unnest(old_columns) c;\n\n    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            -- subscriptions is already filtered by entity\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 400: Bad Request, no primary key']\n        )::realtime.wal_rls;\n\n    -- The claims role does not have SELECT permission to the primary key of entity\n    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 401: Unauthorized']\n        )::realtime.wal_rls;\n\n    else\n        output = jsonb_build_object(\n            'schema', wal ->> 'schema',\n            'table', wal ->> 'table',\n            'type', action,\n            'commit_timestamp', to_char(\n                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),\n                'YYYY-MM-DD\"T\"HH24:MI:SS.MS\"Z\"'\n            ),\n            'columns', (\n                select\n                    jsonb_agg(\n                        jsonb_build_object(\n                            'name', pa.attname,\n                            'type', pt.typname\n                        )\n                        order by pa.attnum asc\n                    )\n                from\n                    pg_attribute pa\n                    join pg_type pt\n                        on pa.atttypid = pt.oid\n                where\n                    attrelid = entity_\n                    and attnum > 0\n                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')\n            )\n        )\n        -- Add \"record\" key for insert and update\n        || case\n            when action in ('INSERT', 'UPDATE') then\n                jsonb_build_object(\n                    'record',\n                    (\n                        select\n                            jsonb_object_agg(\n                                -- if unchanged toast, get column name and value from old record\n                                coalesce((c).name, (oc).name),\n                                case\n                                    when (c).name is null then (oc).value\n                                    else (c).value\n                                end\n                            )\n                        from\n                            unnest(columns) c\n                            full outer join unnest(old_columns) oc\n                                on (c).name = (oc).name\n                        where\n                            coalesce((c).is_selectable, (oc).is_selectable)\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                    )\n                )\n            else '{}'::jsonb\n        end\n        -- Add \"old_record\" key for update and delete\n        || case\n            when action = 'UPDATE' then\n                jsonb_build_object(\n                        'old_record',\n                        (\n                            select jsonb_object_agg((c).name, (c).value)\n                            from unnest(old_columns) c\n                            where\n                                (c).is_selectable\n                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                        )\n                    )\n            when action = 'DELETE' then\n                jsonb_build_object(\n                    'old_record',\n                    (\n                        select jsonb_object_agg((c).name, (c).value)\n                        from unnest(old_columns) c\n                        where\n                            (c).is_selectable\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey\n                    )\n                )\n            else '{}'::jsonb\n        end;\n\n        -- Create the prepared statement\n        if is_rls_enabled and action <> 'DELETE' then\n            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then\n                deallocate walrus_rls_stmt;\n            end if;\n            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);\n        end if;\n\n        visible_to_subscription_ids = '{}';\n\n        for subscription_id, claims in (\n                select\n                    subs.subscription_id,\n                    subs.claims\n                from\n                    unnest(subscriptions) subs\n                where\n                    subs.entity = entity_\n                    and subs.claims_role = working_role\n                    and (\n                        realtime.is_visible_through_filters(columns, subs.filters)\n                        or (\n                          action = 'DELETE'\n                          and realtime.is_visible_through_filters(old_columns, subs.filters)\n                        )\n                    )\n        ) loop\n\n            if not is_rls_enabled or action = 'DELETE' then\n                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n            else\n                -- Check if RLS allows the role to see the record\n                perform\n                    -- Trim leading and trailing quotes from working_role because set_config\n                    -- doesn't recognize the role as valid if they are included\n                    set_config('role', trim(both '\"' from working_role::text), true),\n                    set_config('request.jwt.claims', claims::text, true);\n\n                execute 'execute walrus_rls_stmt' into subscription_has_access;\n\n                if subscription_has_access then\n                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n                end if;\n            end if;\n        end loop;\n\n        perform set_config('role', null, true);\n\n        return next (\n            output,\n            is_rls_enabled,\n            visible_to_subscription_ids,\n            case\n                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']\n                else '{}'\n            end\n        )::realtime.wal_rls;\n\n    end if;\nend loop;\n\nperform set_config('role', null, true);\nend;\n$function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "broadcast_changes",
    "args": "topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text",
    "function_code": "CREATE OR REPLACE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    -- Declare a variable to hold the JSONB representation of the row\n    row_data jsonb := '{}'::jsonb;\nBEGIN\n    IF level = 'STATEMENT' THEN\n        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';\n    END IF;\n    -- Check the operation type and handle accordingly\n    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN\n        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);\n        PERFORM realtime.send (row_data, event_name, topic_name);\n    ELSE\n        RAISE EXCEPTION 'Unexpected operation type: %', operation;\n    END IF;\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;\nEND;\n\n$function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "build_prepared_statement_sql",
    "args": "prepared_statement_name text, entity regclass, columns realtime.wal_column[]",
    "function_code": "CREATE OR REPLACE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[])\n RETURNS text\n LANGUAGE sql\nAS $function$\n      /*\n      Builds a sql string that, if executed, creates a prepared statement to\n      tests retrive a row from *entity* by its primary key columns.\n      Example\n          select realtime.build_prepared_statement_sql('public.notes', '{\"id\"}'::text[], '{\"bigint\"}'::text[])\n      */\n          select\n      'prepare ' || prepared_statement_name || ' as\n          select\n              exists(\n                  select\n                      1\n                  from\n                      ' || entity || '\n                  where\n                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '\n              )'\n          from\n              unnest(columns) pkc\n          where\n              pkc.is_pkey\n          group by\n              entity\n      $function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "cast",
    "args": "val text, type_ regtype",
    "function_code": "CREATE OR REPLACE FUNCTION realtime.\"cast\"(val text, type_ regtype)\n RETURNS jsonb\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n    declare\n      res jsonb;\n    begin\n      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;\n      return res;\n    end\n    $function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "check_equality_op",
    "args": "op realtime.equality_op, type_ regtype, val_1 text, val_2 text",
    "function_code": "CREATE OR REPLACE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text)\n RETURNS boolean\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n      /*\n      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness\n      */\n      declare\n          op_symbol text = (\n              case\n                  when op = 'eq' then '='\n                  when op = 'neq' then '!='\n                  when op = 'lt' then '<'\n                  when op = 'lte' then '<='\n                  when op = 'gt' then '>'\n                  when op = 'gte' then '>='\n                  when op = 'in' then '= any'\n                  else 'UNKNOWN OP'\n              end\n          );\n          res boolean;\n      begin\n          execute format(\n              'select %L::'|| type_::text || ' ' || op_symbol\n              || ' ( %L::'\n              || (\n                  case\n                      when op = 'in' then type_::text || '[]'\n                      else type_::text end\n              )\n              || ')', val_1, val_2) into res;\n          return res;\n      end;\n      $function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "is_visible_through_filters",
    "args": "columns realtime.wal_column[], filters realtime.user_defined_filter[]",
    "function_code": "CREATE OR REPLACE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    Should the record be visible (true) or filtered out (false) after *filters* are applied\n    */\n        select\n            -- Default to allowed when no filters present\n            $2 is null -- no filters. this should not happen because subscriptions has a default\n            or array_length($2, 1) is null -- array length of an empty array is null\n            or bool_and(\n                coalesce(\n                    realtime.check_equality_op(\n                        op:=f.op,\n                        type_:=coalesce(\n                            col.type_oid::regtype, -- null when wal2json version <= 2.4\n                            col.type_name::regtype\n                        ),\n                        -- cast jsonb to text\n                        val_1:=col.value #>> '{}',\n                        val_2:=f.value\n                    ),\n                    false -- if null, filter does not match\n                )\n            )\n        from\n            unnest(filters) f\n            join unnest(columns) col\n                on f.column_name = col.name;\n    $function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "list_changes",
    "args": "publication name, slot_name name, max_changes integer, max_record_bytes integer",
    "function_code": "CREATE OR REPLACE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer)\n RETURNS SETOF realtime.wal_rls\n LANGUAGE sql\n SET log_min_messages TO 'fatal'\nAS $function$\n      with pub as (\n        select\n          concat_ws(\n            ',',\n            case when bool_or(pubinsert) then 'insert' else null end,\n            case when bool_or(pubupdate) then 'update' else null end,\n            case when bool_or(pubdelete) then 'delete' else null end\n          ) as w2j_actions,\n          coalesce(\n            string_agg(\n              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),\n              ','\n            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),\n            ''\n          ) w2j_add_tables\n        from\n          pg_publication pp\n          left join pg_publication_tables ppt\n            on pp.pubname = ppt.pubname\n        where\n          pp.pubname = publication\n        group by\n          pp.pubname\n        limit 1\n      ),\n      w2j as (\n        select\n          x.*, pub.w2j_add_tables\n        from\n          pub,\n          pg_logical_slot_get_changes(\n            slot_name, null, max_changes,\n            'include-pk', 'true',\n            'include-transaction', 'false',\n            'include-timestamp', 'true',\n            'include-type-oids', 'true',\n            'format-version', '2',\n            'actions', pub.w2j_actions,\n            'add-tables', pub.w2j_add_tables\n          ) x\n      )\n      select\n        xyz.wal,\n        xyz.is_rls_enabled,\n        xyz.subscription_ids,\n        xyz.errors\n      from\n        w2j,\n        realtime.apply_rls(\n          wal := w2j.data::jsonb,\n          max_record_bytes := max_record_bytes\n        ) xyz(wal, is_rls_enabled, subscription_ids, errors)\n      where\n        w2j.w2j_add_tables <> ''\n        and xyz.subscription_ids[1] is not null\n    $function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "quote_wal2json",
    "args": "entity regclass",
    "function_code": "CREATE OR REPLACE FUNCTION realtime.quote_wal2json(entity regclass)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\n      select\n        (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n        )\n        || '.'\n        || (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n          )\n      from\n        pg_class pc\n        join pg_namespace nsp\n          on pc.relnamespace = nsp.oid\n      where\n        pc.oid = entity\n    $function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "send",
    "args": "payload jsonb, event text, topic text, private boolean",
    "function_code": "CREATE OR REPLACE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  generated_id uuid;\n  final_payload jsonb;\nBEGIN\n  BEGIN\n    -- Generate a new UUID for the id\n    generated_id := gen_random_uuid();\n\n    -- Check if payload has an 'id' key, if not, add the generated UUID\n    IF payload ? 'id' THEN\n      final_payload := payload;\n    ELSE\n      final_payload := jsonb_set(payload, '{id}', to_jsonb(generated_id));\n    END IF;\n\n    -- Set the topic configuration\n    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);\n\n    -- Attempt to insert the message\n    INSERT INTO realtime.messages (id, payload, event, topic, private, extension)\n    VALUES (generated_id, final_payload, event, topic, private, 'broadcast');\n  EXCEPTION\n    WHEN OTHERS THEN\n      -- Capture and notify the error\n      RAISE WARNING 'ErrorSendingBroadcastMessage: %', SQLERRM;\n  END;\nEND;\n$function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "subscription_check_filters",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION realtime.subscription_check_filters()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n    /*\n    Validates that the user defined filters for a subscription:\n    - refer to valid columns that the claimed role may access\n    - values are coercable to the correct column type\n    */\n    declare\n        col_names text[] = coalesce(\n                array_agg(c.column_name order by c.ordinal_position),\n                '{}'::text[]\n            )\n            from\n                information_schema.columns c\n            where\n                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity\n                and pg_catalog.has_column_privilege(\n                    (new.claims ->> 'role'),\n                    format('%I.%I', c.table_schema, c.table_name)::regclass,\n                    c.column_name,\n                    'SELECT'\n                );\n        filter realtime.user_defined_filter;\n        col_type regtype;\n\n        in_val jsonb;\n    begin\n        for filter in select * from unnest(new.filters) loop\n            -- Filtered column is valid\n            if not filter.column_name = any(col_names) then\n                raise exception 'invalid column for filter %', filter.column_name;\n            end if;\n\n            -- Type is sanitized and safe for string interpolation\n            col_type = (\n                select atttypid::regtype\n                from pg_catalog.pg_attribute\n                where attrelid = new.entity\n                      and attname = filter.column_name\n            );\n            if col_type is null then\n                raise exception 'failed to lookup type for column %', filter.column_name;\n            end if;\n\n            -- Set maximum number of entries for in filter\n            if filter.op = 'in'::realtime.equality_op then\n                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);\n                if coalesce(jsonb_array_length(in_val), 0) > 100 then\n                    raise exception 'too many values for `in` filter. Maximum 100';\n                end if;\n            else\n                -- raises an exception if value is not coercable to type\n                perform realtime.cast(filter.value, col_type);\n            end if;\n\n        end loop;\n\n        -- Apply consistent order to filters so the unique constraint on\n        -- (subscription_id, entity, filters) can't be tricked by a different filter order\n        new.filters = coalesce(\n            array_agg(f order by f.column_name, f.op, f.value),\n            '{}'\n        ) from unnest(new.filters) f;\n\n        return new;\n    end;\n    $function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "to_regrole",
    "args": "role_name text",
    "function_code": "CREATE OR REPLACE FUNCTION realtime.to_regrole(role_name text)\n RETURNS regrole\n LANGUAGE sql\n IMMUTABLE\nAS $function$ select role_name::regrole $function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "topic",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION realtime.topic()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\nselect nullif(current_setting('realtime.topic', true), '')::text;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "can_insert_object",
    "args": "bucketid text, name text, owner uuid, metadata jsonb",
    "function_code": "CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  INSERT INTO \"storage\".\"objects\" (\"bucket_id\", \"name\", \"owner\", \"metadata\") VALUES (bucketid, name, owner, metadata);\n  -- hack to rollback the successful insert\n  RAISE sqlstate 'PT200' using\n  message = 'ROLLBACK',\n  detail = 'rollback successful insert';\nEND\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "delete_leaf_prefixes",
    "args": "bucket_ids text[], names text[]",
    "function_code": "CREATE OR REPLACE FUNCTION storage.delete_leaf_prefixes(bucket_ids text[], names text[])\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_rows_deleted integer;\nBEGIN\n    LOOP\n        WITH candidates AS (\n            SELECT DISTINCT\n                t.bucket_id,\n                unnest(storage.get_prefixes(t.name)) AS name\n            FROM unnest(bucket_ids, names) AS t(bucket_id, name)\n        ),\n        uniq AS (\n             SELECT\n                 bucket_id,\n                 name,\n                 storage.get_level(name) AS level\n             FROM candidates\n             WHERE name <> ''\n             GROUP BY bucket_id, name\n        ),\n        leaf AS (\n             SELECT\n                 p.bucket_id,\n                 p.name,\n                 p.level\n             FROM storage.prefixes AS p\n                  JOIN uniq AS u\n                       ON u.bucket_id = p.bucket_id\n                           AND u.name = p.name\n                           AND u.level = p.level\n             WHERE NOT EXISTS (\n                 SELECT 1\n                 FROM storage.objects AS o\n                 WHERE o.bucket_id = p.bucket_id\n                   AND o.level = p.level + 1\n                   AND o.name COLLATE \"C\" LIKE p.name || '/%'\n             )\n             AND NOT EXISTS (\n                 SELECT 1\n                 FROM storage.prefixes AS c\n                 WHERE c.bucket_id = p.bucket_id\n                   AND c.level = p.level + 1\n                   AND c.name COLLATE \"C\" LIKE p.name || '/%'\n             )\n        )\n        DELETE\n        FROM storage.prefixes AS p\n            USING leaf AS l\n        WHERE p.bucket_id = l.bucket_id\n          AND p.name = l.name\n          AND p.level = l.level;\n\n        GET DIAGNOSTICS v_rows_deleted = ROW_COUNT;\n        EXIT WHEN v_rows_deleted = 0;\n    END LOOP;\nEND;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "enforce_bucket_name_length",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION storage.enforce_bucket_name_length()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n    if length(new.name) > 100 then\n        raise exception 'bucket name \"%\" is too long (% characters). Max is 100.', new.name, length(new.name);\n    end if;\n    return new;\nend;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "extension",
    "args": "name text",
    "function_code": "CREATE OR REPLACE FUNCTION storage.extension(name text)\n RETURNS text\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    _parts text[];\n    _filename text;\nBEGIN\n    SELECT string_to_array(name, '/') INTO _parts;\n    SELECT _parts[array_length(_parts,1)] INTO _filename;\n    RETURN reverse(split_part(reverse(_filename), '.', 1));\nEND\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "filename",
    "args": "name text",
    "function_code": "CREATE OR REPLACE FUNCTION storage.filename(name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[array_length(_parts,1)];\nEND\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "foldername",
    "args": "name text",
    "function_code": "CREATE OR REPLACE FUNCTION storage.foldername(name text)\n RETURNS text[]\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    _parts text[];\nBEGIN\n    -- Split on \"/\" to get path segments\n    SELECT string_to_array(name, '/') INTO _parts;\n    -- Return everything except the last segment\n    RETURN _parts[1 : array_length(_parts,1) - 1];\nEND\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "get_common_prefix",
    "args": "p_key text, p_prefix text, p_delimiter text",
    "function_code": "CREATE OR REPLACE FUNCTION storage.get_common_prefix(p_key text, p_prefix text, p_delimiter text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nSELECT CASE\n    WHEN position(p_delimiter IN substring(p_key FROM length(p_prefix) + 1)) > 0\n    THEN left(p_key, length(p_prefix) + position(p_delimiter IN substring(p_key FROM length(p_prefix) + 1)))\n    ELSE NULL\nEND;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "get_level",
    "args": "name text",
    "function_code": "CREATE OR REPLACE FUNCTION storage.get_level(name text)\n RETURNS integer\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\nSELECT array_length(string_to_array(\"name\", '/'), 1);\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "get_prefix",
    "args": "name text",
    "function_code": "CREATE OR REPLACE FUNCTION storage.get_prefix(name text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\nSELECT\n    CASE WHEN strpos(\"name\", '/') > 0 THEN\n             regexp_replace(\"name\", '[\\/]{1}[^\\/]+\\/?$', '')\n         ELSE\n             ''\n        END;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "get_prefixes",
    "args": "name text",
    "function_code": "CREATE OR REPLACE FUNCTION storage.get_prefixes(name text)\n RETURNS text[]\n LANGUAGE plpgsql\n IMMUTABLE STRICT\nAS $function$\nDECLARE\n    parts text[];\n    prefixes text[];\n    prefix text;\nBEGIN\n    -- Split the name into parts by '/'\n    parts := string_to_array(\"name\", '/');\n    prefixes := '{}';\n\n    -- Construct the prefixes, stopping one level below the last part\n    FOR i IN 1..array_length(parts, 1) - 1 LOOP\n            prefix := array_to_string(parts[1:i], '/');\n            prefixes := array_append(prefixes, prefix);\n    END LOOP;\n\n    RETURN prefixes;\nEND;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "get_size_by_bucket",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()\n RETURNS TABLE(size bigint, bucket_id text)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    return query\n        select sum((metadata->>'size')::bigint) as size, obj.bucket_id\n        from \"storage\".objects as obj\n        group by obj.bucket_id;\nEND\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "list_multipart_uploads_with_delimiter",
    "args": "bucket_id text, prefix_param text, delimiter_param text, max_keys integer, next_key_token text, next_upload_token text",
    "function_code": "CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)\n RETURNS TABLE(key text, id text, created_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(key COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))\n                    ELSE\n                        key\n                END AS key, id, created_at\n            FROM\n                storage.s3_multipart_uploads\n            WHERE\n                bucket_id = $5 AND\n                key ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $4 != '''' AND $6 = '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                key COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END AND\n                CASE\n                    WHEN $6 != '''' THEN\n                        id COLLATE \"C\" > $6\n                    ELSE\n                        true\n                    END\n            ORDER BY\n                key COLLATE \"C\" ASC, created_at ASC) as e order by key COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;\nEND;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "list_objects_with_delimiter",
    "args": "_bucket_id text, prefix_param text, delimiter_param text, max_keys integer, start_after text, next_token text, sort_order text",
    "function_code": "CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(_bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text, sort_order text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nDECLARE\n    v_peek_name TEXT;\n    v_current RECORD;\n    v_common_prefix TEXT;\n\n    -- Configuration\n    v_is_asc BOOLEAN;\n    v_prefix TEXT;\n    v_start TEXT;\n    v_upper_bound TEXT;\n    v_file_batch_size INT;\n\n    -- Seek state\n    v_next_seek TEXT;\n    v_count INT := 0;\n\n    -- Dynamic SQL for batch query only\n    v_batch_query TEXT;\n\nBEGIN\n    -- ========================================================================\n    -- INITIALIZATION\n    -- ========================================================================\n    v_is_asc := lower(coalesce(sort_order, 'asc')) = 'asc';\n    v_prefix := coalesce(prefix_param, '');\n    v_start := CASE WHEN coalesce(next_token, '') <> '' THEN next_token ELSE coalesce(start_after, '') END;\n    v_file_batch_size := LEAST(GREATEST(max_keys * 2, 100), 1000);\n\n    -- Calculate upper bound for prefix filtering (bytewise, using COLLATE \"C\")\n    IF v_prefix = '' THEN\n        v_upper_bound := NULL;\n    ELSIF right(v_prefix, 1) = delimiter_param THEN\n        v_upper_bound := left(v_prefix, -1) || chr(ascii(delimiter_param) + 1);\n    ELSE\n        v_upper_bound := left(v_prefix, -1) || chr(ascii(right(v_prefix, 1)) + 1);\n    END IF;\n\n    -- Build batch query (dynamic SQL - called infrequently, amortized over many rows)\n    IF v_is_asc THEN\n        IF v_upper_bound IS NOT NULL THEN\n            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||\n                'FROM storage.objects o WHERE o.bucket_id = $1 AND o.name COLLATE \"C\" >= $2 ' ||\n                'AND o.name COLLATE \"C\" < $3 ORDER BY o.name COLLATE \"C\" ASC LIMIT $4';\n        ELSE\n            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||\n                'FROM storage.objects o WHERE o.bucket_id = $1 AND o.name COLLATE \"C\" >= $2 ' ||\n                'ORDER BY o.name COLLATE \"C\" ASC LIMIT $4';\n        END IF;\n    ELSE\n        IF v_upper_bound IS NOT NULL THEN\n            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||\n                'FROM storage.objects o WHERE o.bucket_id = $1 AND o.name COLLATE \"C\" < $2 ' ||\n                'AND o.name COLLATE \"C\" >= $3 ORDER BY o.name COLLATE \"C\" DESC LIMIT $4';\n        ELSE\n            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||\n                'FROM storage.objects o WHERE o.bucket_id = $1 AND o.name COLLATE \"C\" < $2 ' ||\n                'ORDER BY o.name COLLATE \"C\" DESC LIMIT $4';\n        END IF;\n    END IF;\n\n    -- ========================================================================\n    -- SEEK INITIALIZATION: Determine starting position\n    -- ========================================================================\n    IF v_start = '' THEN\n        IF v_is_asc THEN\n            v_next_seek := v_prefix;\n        ELSE\n            -- DESC without cursor: find the last item in range\n            IF v_upper_bound IS NOT NULL THEN\n                SELECT o.name INTO v_next_seek FROM storage.objects o\n                WHERE o.bucket_id = _bucket_id AND o.name COLLATE \"C\" >= v_prefix AND o.name COLLATE \"C\" < v_upper_bound\n                ORDER BY o.name COLLATE \"C\" DESC LIMIT 1;\n            ELSIF v_prefix <> '' THEN\n                SELECT o.name INTO v_next_seek FROM storage.objects o\n                WHERE o.bucket_id = _bucket_id AND o.name COLLATE \"C\" >= v_prefix\n                ORDER BY o.name COLLATE \"C\" DESC LIMIT 1;\n            ELSE\n                SELECT o.name INTO v_next_seek FROM storage.objects o\n                WHERE o.bucket_id = _bucket_id\n                ORDER BY o.name COLLATE \"C\" DESC LIMIT 1;\n            END IF;\n\n            IF v_next_seek IS NOT NULL THEN\n                v_next_seek := v_next_seek || delimiter_param;\n            ELSE\n                RETURN;\n            END IF;\n        END IF;\n    ELSE\n        -- Cursor provided: determine if it refers to a folder or leaf\n        IF EXISTS (\n            SELECT 1 FROM storage.objects o\n            WHERE o.bucket_id = _bucket_id\n              AND o.name COLLATE \"C\" LIKE v_start || delimiter_param || '%'\n            LIMIT 1\n        ) THEN\n            -- Cursor refers to a folder\n            IF v_is_asc THEN\n                v_next_seek := v_start || chr(ascii(delimiter_param) + 1);\n            ELSE\n                v_next_seek := v_start || delimiter_param;\n            END IF;\n        ELSE\n            -- Cursor refers to a leaf object\n            IF v_is_asc THEN\n                v_next_seek := v_start || delimiter_param;\n            ELSE\n                v_next_seek := v_start;\n            END IF;\n        END IF;\n    END IF;\n\n    -- ========================================================================\n    -- MAIN LOOP: Hybrid peek-then-batch algorithm\n    -- Uses STATIC SQL for peek (hot path) and DYNAMIC SQL for batch\n    -- ========================================================================\n    LOOP\n        EXIT WHEN v_count >= max_keys;\n\n        -- STEP 1: PEEK using STATIC SQL (plan cached, very fast)\n        IF v_is_asc THEN\n            IF v_upper_bound IS NOT NULL THEN\n                SELECT o.name INTO v_peek_name FROM storage.objects o\n                WHERE o.bucket_id = _bucket_id AND o.name COLLATE \"C\" >= v_next_seek AND o.name COLLATE \"C\" < v_upper_bound\n                ORDER BY o.name COLLATE \"C\" ASC LIMIT 1;\n            ELSE\n                SELECT o.name INTO v_peek_name FROM storage.objects o\n                WHERE o.bucket_id = _bucket_id AND o.name COLLATE \"C\" >= v_next_seek\n                ORDER BY o.name COLLATE \"C\" ASC LIMIT 1;\n            END IF;\n        ELSE\n            IF v_upper_bound IS NOT NULL THEN\n                SELECT o.name INTO v_peek_name FROM storage.objects o\n                WHERE o.bucket_id = _bucket_id AND o.name COLLATE \"C\" < v_next_seek AND o.name COLLATE \"C\" >= v_prefix\n                ORDER BY o.name COLLATE \"C\" DESC LIMIT 1;\n            ELSIF v_prefix <> '' THEN\n                SELECT o.name INTO v_peek_name FROM storage.objects o\n                WHERE o.bucket_id = _bucket_id AND o.name COLLATE \"C\" < v_next_seek AND o.name COLLATE \"C\" >= v_prefix\n                ORDER BY o.name COLLATE \"C\" DESC LIMIT 1;\n            ELSE\n                SELECT o.name INTO v_peek_name FROM storage.objects o\n                WHERE o.bucket_id = _bucket_id AND o.name COLLATE \"C\" < v_next_seek\n                ORDER BY o.name COLLATE \"C\" DESC LIMIT 1;\n            END IF;\n        END IF;\n\n        EXIT WHEN v_peek_name IS NULL;\n\n        -- STEP 2: Check if this is a FOLDER or FILE\n        v_common_prefix := storage.get_common_prefix(v_peek_name, v_prefix, delimiter_param);\n\n        IF v_common_prefix IS NOT NULL THEN\n            -- FOLDER: Emit and skip to next folder (no heap access needed)\n            name := rtrim(v_common_prefix, delimiter_param);\n            id := NULL;\n            updated_at := NULL;\n            created_at := NULL;\n            last_accessed_at := NULL;\n            metadata := NULL;\n            RETURN NEXT;\n            v_count := v_count + 1;\n\n            -- Advance seek past the folder range\n            IF v_is_asc THEN\n                v_next_seek := left(v_common_prefix, -1) || chr(ascii(delimiter_param) + 1);\n            ELSE\n                v_next_seek := v_common_prefix;\n            END IF;\n        ELSE\n            -- FILE: Batch fetch using DYNAMIC SQL (overhead amortized over many rows)\n            -- For ASC: upper_bound is the exclusive upper limit (< condition)\n            -- For DESC: prefix is the inclusive lower limit (>= condition)\n            FOR v_current IN EXECUTE v_batch_query USING _bucket_id, v_next_seek,\n                CASE WHEN v_is_asc THEN COALESCE(v_upper_bound, v_prefix) ELSE v_prefix END, v_file_batch_size\n            LOOP\n                v_common_prefix := storage.get_common_prefix(v_current.name, v_prefix, delimiter_param);\n\n                IF v_common_prefix IS NOT NULL THEN\n                    -- Hit a folder: exit batch, let peek handle it\n                    v_next_seek := v_current.name;\n                    EXIT;\n                END IF;\n\n                -- Emit file\n                name := v_current.name;\n                id := v_current.id;\n                updated_at := v_current.updated_at;\n                created_at := v_current.created_at;\n                last_accessed_at := v_current.last_accessed_at;\n                metadata := v_current.metadata;\n                RETURN NEXT;\n                v_count := v_count + 1;\n\n                -- Advance seek past this file\n                IF v_is_asc THEN\n                    v_next_seek := v_current.name || delimiter_param;\n                ELSE\n                    v_next_seek := v_current.name;\n                END IF;\n\n                EXIT WHEN v_count >= max_keys;\n            END LOOP;\n        END IF;\n    END LOOP;\nEND;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "operation",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION storage.operation()\n RETURNS text\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    RETURN current_setting('storage.operation', true);\nEND;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "protect_delete",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION storage.protect_delete()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Check if storage.allow_delete_query is set to 'true'\n    IF COALESCE(current_setting('storage.allow_delete_query', true), 'false') != 'true' THEN\n        RAISE EXCEPTION 'Direct deletion from storage tables is not allowed. Use the Storage API instead.'\n            USING HINT = 'This prevents accidental data loss from orphaned objects.',\n                  ERRCODE = '42501';\n    END IF;\n    RETURN NULL;\nEND;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "search",
    "args": "prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text",
    "function_code": "CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nDECLARE\n    v_peek_name TEXT;\n    v_current RECORD;\n    v_common_prefix TEXT;\n    v_delimiter CONSTANT TEXT := '/';\n\n    -- Configuration\n    v_limit INT;\n    v_prefix TEXT;\n    v_prefix_lower TEXT;\n    v_is_asc BOOLEAN;\n    v_order_by TEXT;\n    v_sort_order TEXT;\n    v_upper_bound TEXT;\n    v_file_batch_size INT;\n\n    -- Dynamic SQL for batch query only\n    v_batch_query TEXT;\n\n    -- Seek state\n    v_next_seek TEXT;\n    v_count INT := 0;\n    v_skipped INT := 0;\nBEGIN\n    -- ========================================================================\n    -- INITIALIZATION\n    -- ========================================================================\n    v_limit := LEAST(coalesce(limits, 100), 1500);\n    v_prefix := coalesce(prefix, '') || coalesce(search, '');\n    v_prefix_lower := lower(v_prefix);\n    v_is_asc := lower(coalesce(sortorder, 'asc')) = 'asc';\n    v_file_batch_size := LEAST(GREATEST(v_limit * 2, 100), 1000);\n\n    -- Validate sort column\n    CASE lower(coalesce(sortcolumn, 'name'))\n        WHEN 'name' THEN v_order_by := 'name';\n        WHEN 'updated_at' THEN v_order_by := 'updated_at';\n        WHEN 'created_at' THEN v_order_by := 'created_at';\n        WHEN 'last_accessed_at' THEN v_order_by := 'last_accessed_at';\n        ELSE v_order_by := 'name';\n    END CASE;\n\n    v_sort_order := CASE WHEN v_is_asc THEN 'asc' ELSE 'desc' END;\n\n    -- ========================================================================\n    -- NON-NAME SORTING: Use path_tokens approach (unchanged)\n    -- ========================================================================\n    IF v_order_by != 'name' THEN\n        RETURN QUERY EXECUTE format(\n            $sql$\n            WITH folders AS (\n                SELECT path_tokens[$1] AS folder\n                FROM storage.objects\n                WHERE objects.name ILIKE $2 || '%%'\n                  AND bucket_id = $3\n                  AND array_length(objects.path_tokens, 1) <> $1\n                GROUP BY folder\n                ORDER BY folder %s\n            )\n            (SELECT folder AS \"name\",\n                   NULL::uuid AS id,\n                   NULL::timestamptz AS updated_at,\n                   NULL::timestamptz AS created_at,\n                   NULL::timestamptz AS last_accessed_at,\n                   NULL::jsonb AS metadata FROM folders)\n            UNION ALL\n            (SELECT path_tokens[$1] AS \"name\",\n                   id, updated_at, created_at, last_accessed_at, metadata\n             FROM storage.objects\n             WHERE objects.name ILIKE $2 || '%%'\n               AND bucket_id = $3\n               AND array_length(objects.path_tokens, 1) = $1\n             ORDER BY %I %s)\n            LIMIT $4 OFFSET $5\n            $sql$, v_sort_order, v_order_by, v_sort_order\n        ) USING levels, v_prefix, bucketname, v_limit, offsets;\n        RETURN;\n    END IF;\n\n    -- ========================================================================\n    -- NAME SORTING: Hybrid skip-scan with batch optimization\n    -- ========================================================================\n\n    -- Calculate upper bound for prefix filtering\n    IF v_prefix_lower = '' THEN\n        v_upper_bound := NULL;\n    ELSIF right(v_prefix_lower, 1) = v_delimiter THEN\n        v_upper_bound := left(v_prefix_lower, -1) || chr(ascii(v_delimiter) + 1);\n    ELSE\n        v_upper_bound := left(v_prefix_lower, -1) || chr(ascii(right(v_prefix_lower, 1)) + 1);\n    END IF;\n\n    -- Build batch query (dynamic SQL - called infrequently, amortized over many rows)\n    IF v_is_asc THEN\n        IF v_upper_bound IS NOT NULL THEN\n            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||\n                'FROM storage.objects o WHERE o.bucket_id = $1 AND lower(o.name) COLLATE \"C\" >= $2 ' ||\n                'AND lower(o.name) COLLATE \"C\" < $3 ORDER BY lower(o.name) COLLATE \"C\" ASC LIMIT $4';\n        ELSE\n            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||\n                'FROM storage.objects o WHERE o.bucket_id = $1 AND lower(o.name) COLLATE \"C\" >= $2 ' ||\n                'ORDER BY lower(o.name) COLLATE \"C\" ASC LIMIT $4';\n        END IF;\n    ELSE\n        IF v_upper_bound IS NOT NULL THEN\n            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||\n                'FROM storage.objects o WHERE o.bucket_id = $1 AND lower(o.name) COLLATE \"C\" < $2 ' ||\n                'AND lower(o.name) COLLATE \"C\" >= $3 ORDER BY lower(o.name) COLLATE \"C\" DESC LIMIT $4';\n        ELSE\n            v_batch_query := 'SELECT o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata ' ||\n                'FROM storage.objects o WHERE o.bucket_id = $1 AND lower(o.name) COLLATE \"C\" < $2 ' ||\n                'ORDER BY lower(o.name) COLLATE \"C\" DESC LIMIT $4';\n        END IF;\n    END IF;\n\n    -- Initialize seek position\n    IF v_is_asc THEN\n        v_next_seek := v_prefix_lower;\n    ELSE\n        -- DESC: find the last item in range first (static SQL)\n        IF v_upper_bound IS NOT NULL THEN\n            SELECT o.name INTO v_peek_name FROM storage.objects o\n            WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE \"C\" >= v_prefix_lower AND lower(o.name) COLLATE \"C\" < v_upper_bound\n            ORDER BY lower(o.name) COLLATE \"C\" DESC LIMIT 1;\n        ELSIF v_prefix_lower <> '' THEN\n            SELECT o.name INTO v_peek_name FROM storage.objects o\n            WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE \"C\" >= v_prefix_lower\n            ORDER BY lower(o.name) COLLATE \"C\" DESC LIMIT 1;\n        ELSE\n            SELECT o.name INTO v_peek_name FROM storage.objects o\n            WHERE o.bucket_id = bucketname\n            ORDER BY lower(o.name) COLLATE \"C\" DESC LIMIT 1;\n        END IF;\n\n        IF v_peek_name IS NOT NULL THEN\n            v_next_seek := lower(v_peek_name) || v_delimiter;\n        ELSE\n            RETURN;\n        END IF;\n    END IF;\n\n    -- ========================================================================\n    -- MAIN LOOP: Hybrid peek-then-batch algorithm\n    -- Uses STATIC SQL for peek (hot path) and DYNAMIC SQL for batch\n    -- ========================================================================\n    LOOP\n        EXIT WHEN v_count >= v_limit;\n\n        -- STEP 1: PEEK using STATIC SQL (plan cached, very fast)\n        IF v_is_asc THEN\n            IF v_upper_bound IS NOT NULL THEN\n                SELECT o.name INTO v_peek_name FROM storage.objects o\n                WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE \"C\" >= v_next_seek AND lower(o.name) COLLATE \"C\" < v_upper_bound\n                ORDER BY lower(o.name) COLLATE \"C\" ASC LIMIT 1;\n            ELSE\n                SELECT o.name INTO v_peek_name FROM storage.objects o\n                WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE \"C\" >= v_next_seek\n                ORDER BY lower(o.name) COLLATE \"C\" ASC LIMIT 1;\n            END IF;\n        ELSE\n            IF v_upper_bound IS NOT NULL THEN\n                SELECT o.name INTO v_peek_name FROM storage.objects o\n                WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE \"C\" < v_next_seek AND lower(o.name) COLLATE \"C\" >= v_prefix_lower\n                ORDER BY lower(o.name) COLLATE \"C\" DESC LIMIT 1;\n            ELSIF v_prefix_lower <> '' THEN\n                SELECT o.name INTO v_peek_name FROM storage.objects o\n                WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE \"C\" < v_next_seek AND lower(o.name) COLLATE \"C\" >= v_prefix_lower\n                ORDER BY lower(o.name) COLLATE \"C\" DESC LIMIT 1;\n            ELSE\n                SELECT o.name INTO v_peek_name FROM storage.objects o\n                WHERE o.bucket_id = bucketname AND lower(o.name) COLLATE \"C\" < v_next_seek\n                ORDER BY lower(o.name) COLLATE \"C\" DESC LIMIT 1;\n            END IF;\n        END IF;\n\n        EXIT WHEN v_peek_name IS NULL;\n\n        -- STEP 2: Check if this is a FOLDER or FILE\n        v_common_prefix := storage.get_common_prefix(lower(v_peek_name), v_prefix_lower, v_delimiter);\n\n        IF v_common_prefix IS NOT NULL THEN\n            -- FOLDER: Handle offset, emit if needed, skip to next folder\n            IF v_skipped < offsets THEN\n                v_skipped := v_skipped + 1;\n            ELSE\n                name := split_part(rtrim(storage.get_common_prefix(v_peek_name, v_prefix, v_delimiter), v_delimiter), v_delimiter, levels);\n                id := NULL;\n                updated_at := NULL;\n                created_at := NULL;\n                last_accessed_at := NULL;\n                metadata := NULL;\n                RETURN NEXT;\n                v_count := v_count + 1;\n            END IF;\n\n            -- Advance seek past the folder range\n            IF v_is_asc THEN\n                v_next_seek := lower(left(v_common_prefix, -1)) || chr(ascii(v_delimiter) + 1);\n            ELSE\n                v_next_seek := lower(v_common_prefix);\n            END IF;\n        ELSE\n            -- FILE: Batch fetch using DYNAMIC SQL (overhead amortized over many rows)\n            -- For ASC: upper_bound is the exclusive upper limit (< condition)\n            -- For DESC: prefix_lower is the inclusive lower limit (>= condition)\n            FOR v_current IN EXECUTE v_batch_query\n                USING bucketname, v_next_seek,\n                    CASE WHEN v_is_asc THEN COALESCE(v_upper_bound, v_prefix_lower) ELSE v_prefix_lower END, v_file_batch_size\n            LOOP\n                v_common_prefix := storage.get_common_prefix(lower(v_current.name), v_prefix_lower, v_delimiter);\n\n                IF v_common_prefix IS NOT NULL THEN\n                    -- Hit a folder: exit batch, let peek handle it\n                    v_next_seek := lower(v_current.name);\n                    EXIT;\n                END IF;\n\n                -- Handle offset skipping\n                IF v_skipped < offsets THEN\n                    v_skipped := v_skipped + 1;\n                ELSE\n                    -- Emit file\n                    name := split_part(v_current.name, v_delimiter, levels);\n                    id := v_current.id;\n                    updated_at := v_current.updated_at;\n                    created_at := v_current.created_at;\n                    last_accessed_at := v_current.last_accessed_at;\n                    metadata := v_current.metadata;\n                    RETURN NEXT;\n                    v_count := v_count + 1;\n                END IF;\n\n                -- Advance seek past this file\n                IF v_is_asc THEN\n                    v_next_seek := lower(v_current.name) || v_delimiter;\n                ELSE\n                    v_next_seek := lower(v_current.name);\n                END IF;\n\n                EXIT WHEN v_count >= v_limit;\n            END LOOP;\n        END IF;\n    END LOOP;\nEND;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "search_by_timestamp",
    "args": "p_prefix text, p_bucket_id text, p_limit integer, p_level integer, p_start_after text, p_sort_order text, p_sort_column text, p_sort_column_after text",
    "function_code": "CREATE OR REPLACE FUNCTION storage.search_by_timestamp(p_prefix text, p_bucket_id text, p_limit integer, p_level integer, p_start_after text, p_sort_order text, p_sort_column text, p_sort_column_after text)\n RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nDECLARE\n    v_cursor_op text;\n    v_query text;\n    v_prefix text;\nBEGIN\n    v_prefix := coalesce(p_prefix, '');\n\n    IF p_sort_order = 'asc' THEN\n        v_cursor_op := '>';\n    ELSE\n        v_cursor_op := '<';\n    END IF;\n\n    v_query := format($sql$\n        WITH raw_objects AS (\n            SELECT\n                o.name AS obj_name,\n                o.id AS obj_id,\n                o.updated_at AS obj_updated_at,\n                o.created_at AS obj_created_at,\n                o.last_accessed_at AS obj_last_accessed_at,\n                o.metadata AS obj_metadata,\n                storage.get_common_prefix(o.name, $1, '/') AS common_prefix\n            FROM storage.objects o\n            WHERE o.bucket_id = $2\n              AND o.name COLLATE \"C\" LIKE $1 || '%%'\n        ),\n        -- Aggregate common prefixes (folders)\n        -- Both created_at and updated_at use MIN(obj_created_at) to match the old prefixes table behavior\n        aggregated_prefixes AS (\n            SELECT\n                rtrim(common_prefix, '/') AS name,\n                NULL::uuid AS id,\n                MIN(obj_created_at) AS updated_at,\n                MIN(obj_created_at) AS created_at,\n                NULL::timestamptz AS last_accessed_at,\n                NULL::jsonb AS metadata,\n                TRUE AS is_prefix\n            FROM raw_objects\n            WHERE common_prefix IS NOT NULL\n            GROUP BY common_prefix\n        ),\n        leaf_objects AS (\n            SELECT\n                obj_name AS name,\n                obj_id AS id,\n                obj_updated_at AS updated_at,\n                obj_created_at AS created_at,\n                obj_last_accessed_at AS last_accessed_at,\n                obj_metadata AS metadata,\n                FALSE AS is_prefix\n            FROM raw_objects\n            WHERE common_prefix IS NULL\n        ),\n        combined AS (\n            SELECT * FROM aggregated_prefixes\n            UNION ALL\n            SELECT * FROM leaf_objects\n        ),\n        filtered AS (\n            SELECT *\n            FROM combined\n            WHERE (\n                $5 = ''\n                OR ROW(\n                    date_trunc('milliseconds', %I),\n                    name COLLATE \"C\"\n                ) %s ROW(\n                    COALESCE(NULLIF($6, '')::timestamptz, 'epoch'::timestamptz),\n                    $5\n                )\n            )\n        )\n        SELECT\n            split_part(name, '/', $3) AS key,\n            name,\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n        FROM filtered\n        ORDER BY\n            COALESCE(date_trunc('milliseconds', %I), 'epoch'::timestamptz) %s,\n            name COLLATE \"C\" %s\n        LIMIT $4\n    $sql$,\n        p_sort_column,\n        v_cursor_op,\n        p_sort_column,\n        p_sort_order,\n        p_sort_order\n    );\n\n    RETURN QUERY EXECUTE v_query\n    USING v_prefix, p_bucket_id, p_level, p_limit, p_start_after, p_sort_column_after;\nEND;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "search_legacy_v1",
    "args": "prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text",
    "function_code": "CREATE OR REPLACE FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n    v_order_by text;\n    v_sort_order text;\nbegin\n    case\n        when sortcolumn = 'name' then\n            v_order_by = 'name';\n        when sortcolumn = 'updated_at' then\n            v_order_by = 'updated_at';\n        when sortcolumn = 'created_at' then\n            v_order_by = 'created_at';\n        when sortcolumn = 'last_accessed_at' then\n            v_order_by = 'last_accessed_at';\n        else\n            v_order_by = 'name';\n        end case;\n\n    case\n        when sortorder = 'asc' then\n            v_sort_order = 'asc';\n        when sortorder = 'desc' then\n            v_sort_order = 'desc';\n        else\n            v_sort_order = 'asc';\n        end case;\n\n    v_order_by = v_order_by || ' ' || v_sort_order;\n\n    return query execute\n        'with folders as (\n           select path_tokens[$1] as folder\n           from storage.objects\n             where objects.name ilike $2 || $3 || ''%''\n               and bucket_id = $4\n               and array_length(objects.path_tokens, 1) <> $1\n           group by folder\n           order by folder ' || v_sort_order || '\n     )\n     (select folder as \"name\",\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[$1] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where objects.name ilike $2 || $3 || ''%''\n       and bucket_id = $4\n       and array_length(objects.path_tokens, 1) = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "search_v2",
    "args": "prefix text, bucket_name text, limits integer, levels integer, start_after text, sort_order text, sort_column text, sort_column_after text",
    "function_code": "CREATE OR REPLACE FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text, sort_order text DEFAULT 'asc'::text, sort_column text DEFAULT 'name'::text, sort_column_after text DEFAULT ''::text)\n RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nDECLARE\n    v_sort_col text;\n    v_sort_ord text;\n    v_limit int;\nBEGIN\n    -- Cap limit to maximum of 1500 records\n    v_limit := LEAST(coalesce(limits, 100), 1500);\n\n    -- Validate and normalize sort_order\n    v_sort_ord := lower(coalesce(sort_order, 'asc'));\n    IF v_sort_ord NOT IN ('asc', 'desc') THEN\n        v_sort_ord := 'asc';\n    END IF;\n\n    -- Validate and normalize sort_column\n    v_sort_col := lower(coalesce(sort_column, 'name'));\n    IF v_sort_col NOT IN ('name', 'updated_at', 'created_at') THEN\n        v_sort_col := 'name';\n    END IF;\n\n    -- Route to appropriate implementation\n    IF v_sort_col = 'name' THEN\n        -- Use list_objects_with_delimiter for name sorting (most efficient: O(k * log n))\n        RETURN QUERY\n        SELECT\n            split_part(l.name, '/', levels) AS key,\n            l.name AS name,\n            l.id,\n            l.updated_at,\n            l.created_at,\n            l.last_accessed_at,\n            l.metadata\n        FROM storage.list_objects_with_delimiter(\n            bucket_name,\n            coalesce(prefix, ''),\n            '/',\n            v_limit,\n            start_after,\n            '',\n            v_sort_ord\n        ) l;\n    ELSE\n        -- Use aggregation approach for timestamp sorting\n        -- Not efficient for large datasets but supports correct pagination\n        RETURN QUERY SELECT * FROM storage.search_by_timestamp(\n            prefix, bucket_name, v_limit, levels, start_after,\n            v_sort_ord, v_sort_col, sort_column_after\n        );\n    END IF;\nEND;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "update_updated_at_column",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION storage.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW; \nEND;\n$function$\n"
  },
  {
    "schema_name": "vault",
    "function_name": "_crypto_aead_det_decrypt",
    "args": "message bytea, additional bytea, key_id bigint, context bytea, nonce bytea",
    "function_code": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_decrypt_by_id$function$\n"
  },
  {
    "schema_name": "vault",
    "function_name": "_crypto_aead_det_encrypt",
    "args": "message bytea, additional bytea, key_id bigint, context bytea, nonce bytea",
    "function_code": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_encrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_encrypt_by_id$function$\n"
  },
  {
    "schema_name": "vault",
    "function_name": "_crypto_aead_det_noncegen",
    "args": "",
    "function_code": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_noncegen()\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_noncegen$function$\n"
  },
  {
    "schema_name": "vault",
    "function_name": "create_secret",
    "args": "new_secret text, new_name text, new_description text, new_key_id uuid",
    "function_code": "CREATE OR REPLACE FUNCTION vault.create_secret(new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  rec record;\nBEGIN\n  INSERT INTO vault.secrets (secret, name, description)\n  VALUES (\n    new_secret,\n    new_name,\n    new_description\n  )\n  RETURNING * INTO rec;\n  UPDATE vault.secrets s\n  SET secret = encode(vault._crypto_aead_det_encrypt(\n    message := convert_to(rec.secret, 'utf8'),\n    additional := convert_to(s.id::text, 'utf8'),\n    key_id := 0,\n    context := 'pgsodium'::bytea,\n    nonce := rec.nonce\n  ), 'base64')\n  WHERE id = rec.id;\n  RETURN rec.id;\nEND\n$function$\n"
  },
  {
    "schema_name": "vault",
    "function_name": "update_secret",
    "args": "secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid",
    "function_code": "CREATE OR REPLACE FUNCTION vault.update_secret(secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  decrypted_secret text := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE id = secret_id);\nBEGIN\n  UPDATE vault.secrets s\n  SET\n    secret = CASE WHEN new_secret IS NULL THEN s.secret\n                  ELSE encode(vault._crypto_aead_det_encrypt(\n                    message := convert_to(new_secret, 'utf8'),\n                    additional := convert_to(s.id::text, 'utf8'),\n                    key_id := 0,\n                    context := 'pgsodium'::bytea,\n                    nonce := s.nonce\n                  ), 'base64') END,\n    name = coalesce(new_name, s.name),\n    description = coalesce(new_description, s.description),\n    updated_at = now()\n  WHERE s.id = secret_id;\nEND\n$function$\n"
  }
]