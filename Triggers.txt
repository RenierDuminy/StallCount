[
  {
    "schema_name": "auth",
    "table_name": "users",
    "trigger_name": "on_auth_user_created",
    "trigger_def": "CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION handle_new_user()",
    "function_name": "handle_new_user",
    "function_code": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\ndeclare\r\n  viewer_role_id smallint;\r\nbegin\r\n  -- create profile\r\n  insert into public.profiles (id, email, full_name)\r\n  values (\r\n    new.id,\r\n    new.email,\r\n    coalesce(new.raw_user_meta_data->>'full_name', new.email)\r\n  )\r\n  on conflict (id) do nothing;\r\n\r\n  -- resolve viewer role id by name\r\n  select id into viewer_role_id\r\n  from public.roles\r\n  where name = 'viewer'\r\n  limit 1;\r\n\r\n  -- assign default viewer role if it exists\r\n  if viewer_role_id is not null then\r\n    insert into public.user_roles (user_id, role_id, granted_by)\r\n    values (new.id, viewer_role_id, new.id)\r\n    on conflict (user_id, role_id) do nothing;\r\n  end if;\r\n\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "bracket_nodes",
    "trigger_name": "trg_audit_bracket_nodes",
    "trigger_def": "CREATE TRIGGER trg_audit_bracket_nodes AFTER INSERT OR DELETE OR UPDATE ON bracket_nodes FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "brackets",
    "trigger_name": "trg_audit_brackets",
    "trigger_def": "CREATE TRIGGER trg_audit_brackets AFTER INSERT OR DELETE OR UPDATE ON brackets FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "division_teams",
    "trigger_name": "trg_audit_division_teams",
    "trigger_def": "CREATE TRIGGER trg_audit_division_teams AFTER INSERT OR DELETE OR UPDATE ON division_teams FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "divisions",
    "trigger_name": "trg_audit_divisions",
    "trigger_def": "CREATE TRIGGER trg_audit_divisions AFTER INSERT OR DELETE OR UPDATE ON divisions FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "event_user_roles",
    "trigger_name": "trg_audit_event_user_roles",
    "trigger_def": "CREATE TRIGGER trg_audit_event_user_roles AFTER INSERT OR DELETE OR UPDATE ON event_user_roles FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "event_user_roles",
    "trigger_name": "trg_event_user_roles_enforce_scope",
    "trigger_def": "CREATE TRIGGER trg_event_user_roles_enforce_scope BEFORE INSERT OR UPDATE OF role_id ON event_user_roles FOR EACH ROW EXECUTE FUNCTION enforce_event_user_roles_event_scope()",
    "function_name": "enforce_event_user_roles_event_scope",
    "function_code": "CREATE OR REPLACE FUNCTION public.enforce_event_user_roles_event_scope()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  v_scope text;\r\nbegin\r\n  select scope\r\n    into v_scope\r\n  from public.roles\r\n  where id = new.role_id;\r\n\r\n  if v_scope is null then\r\n    raise exception 'Role % does not exist.', new.role_id;\r\n  end if;\r\n\r\n  if v_scope <> 'event' then\r\n    raise exception\r\n      'Role % has scope \"%\". Only event-scoped roles are allowed in event_user_roles.',\r\n      new.role_id,\r\n      v_scope;\r\n  end if;\r\n\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "events",
    "trigger_name": "trg_audit_events",
    "trigger_def": "CREATE TRIGGER trg_audit_events AFTER INSERT OR DELETE OR UPDATE ON events FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "live_events",
    "trigger_name": "trg_audit_live_events",
    "trigger_def": "CREATE TRIGGER trg_audit_live_events AFTER INSERT OR DELETE OR UPDATE ON live_events FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "match_events",
    "trigger_name": "trg_audit_match_events",
    "trigger_def": "CREATE TRIGGER trg_audit_match_events AFTER INSERT OR DELETE OR UPDATE ON match_events FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "match_logs",
    "trigger_name": "trg_audit_match_logs",
    "trigger_def": "CREATE TRIGGER trg_audit_match_logs AFTER INSERT OR DELETE OR UPDATE ON match_logs FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "match_logs",
    "trigger_name": "trg_match_logs_enqueue_live_event",
    "trigger_def": "CREATE TRIGGER trg_match_logs_enqueue_live_event AFTER INSERT ON match_logs FOR EACH ROW EXECUTE FUNCTION enqueue_live_event_from_log()",
    "function_name": "enqueue_live_event_from_log",
    "function_code": "CREATE OR REPLACE FUNCTION public.enqueue_live_event_from_log()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$declare\r\n  event_code text;\r\n  payload jsonb;\r\n  match_rec record;\r\n  match_label text;\r\n  team_label text;\r\n  player_label text;\r\n  secondary_player_label text;\r\n  human_event text;\r\nbegin\r\n  select code into event_code\r\n  from public.match_events\r\n  where id = new.event_type_id;\r\n\r\n  if event_code is null then\r\n    return new;\r\n  end if;\r\n\r\n  select\r\n    m.id,\r\n    m.event_id,\r\n    m.division_id,\r\n    m.team_a,\r\n    m.team_b,\r\n    m.start_time,\r\n    ta.name as team_a_name,\r\n    tb.name as team_b_name,\r\n    ev.name as event_name,\r\n    d.name as division_name\r\n  into match_rec\r\n  from public.matches m\r\n  left join public.teams ta on ta.id = m.team_a\r\n  left join public.teams tb on tb.id = m.team_b\r\n  left join public.events ev on ev.id = m.event_id\r\n  left join public.divisions d on d.id = m.division_id\r\n  where m.id = new.match_id;\r\n\r\n  match_label := coalesce(nullif(match_rec.team_a_name, ''), 'Team A')\r\n    || ' vs '\r\n    || coalesce(nullif(match_rec.team_b_name, ''), 'Team B');\r\n\r\n  if match_label is null or match_label = ' vs ' then\r\n    match_label := coalesce(new.match_id::text, 'Match');\r\n  end if;\r\n\r\n  if new.team_id is not null then\r\n    if new.team_id = match_rec.team_a then\r\n      team_label := coalesce(nullif(match_rec.team_a_name, ''), 'Team A');\r\n    elsif new.team_id = match_rec.team_b then\r\n      team_label := coalesce(nullif(match_rec.team_b_name, ''), 'Team B');\r\n    else\r\n      select name into team_label\r\n      from public.teams\r\n      where id = new.team_id;\r\n    end if;\r\n  end if;\r\n\r\n  if new.actor_id is not null then\r\n    select name into player_label\r\n    from public.player\r\n    where id = new.actor_id;\r\n  end if;\r\n\r\n  if new.secondary_actor_id is not null then\r\n    select name into secondary_player_label\r\n    from public.player\r\n    where id = new.secondary_actor_id;\r\n  end if;\r\n\r\n  human_event := initcap(replace(event_code, '_', ' '));\r\n\r\n  payload := jsonb_build_object(\r\n    'log_id', new.id,\r\n    'match_id', new.match_id,\r\n    'event_id', match_rec.event_id,\r\n    'division_id', match_rec.division_id,\r\n    'team_id', new.team_id,\r\n    'team_name', team_label,\r\n    'player_id', new.actor_id,\r\n    'player_name', player_label,\r\n    'secondary_player_id', new.secondary_actor_id,\r\n    'secondary_player_name', secondary_player_label,\r\n    'abba_line', new.abba_line,\r\n    'match_start_time', match_rec.start_time,\r\n    'match_name', match_label,\r\n    'division_name', match_rec.division_name,\r\n    'target_name', coalesce(team_label, match_label),\r\n    'title', human_event || ' - ' || coalesce(team_label, match_label),\r\n    'body', format('%s for %s', human_event, coalesce(team_label, match_label)),\r\n    'url', format('/matches/%s', new.match_id)\r\n  );\r\n\r\n  insert into public.live_events (match_id, event_type, data)\r\n  values (new.match_id, event_code, payload);\r\n\r\n  return new;\r\nend;$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "match_logs",
    "trigger_name": "trg_match_logs_player_stats",
    "trigger_def": "CREATE TRIGGER trg_match_logs_player_stats AFTER INSERT OR DELETE OR UPDATE ON match_logs FOR EACH ROW EXECUTE FUNCTION trg_player_stats_from_match_logs()",
    "function_name": "trg_player_stats_from_match_logs",
    "function_code": "CREATE OR REPLACE FUNCTION public.trg_player_stats_from_match_logs()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  if TG_OP = 'INSERT' then\r\n    perform public.apply_match_log_delta(\r\n      NEW.match_id,\r\n      NEW.team_id,\r\n      NEW.actor_id,\r\n      NEW.secondary_actor_id,\r\n      NEW.event_type_id,\r\n      1\r\n    );\r\n    return NEW;\r\n  elsif TG_OP = 'DELETE' then\r\n    perform public.apply_match_log_delta(\r\n      OLD.match_id,\r\n      OLD.team_id,\r\n      OLD.actor_id,\r\n      OLD.secondary_actor_id,\r\n      OLD.event_type_id,\r\n      -1\r\n    );\r\n    return OLD;\r\n  elsif TG_OP = 'UPDATE' then\r\n    perform public.apply_match_log_delta(\r\n      OLD.match_id,\r\n      OLD.team_id,\r\n      OLD.actor_id,\r\n      OLD.secondary_actor_id,\r\n      OLD.event_type_id,\r\n      -1\r\n    );\r\n    perform public.apply_match_log_delta(\r\n      NEW.match_id,\r\n      NEW.team_id,\r\n      NEW.actor_id,\r\n      NEW.secondary_actor_id,\r\n      NEW.event_type_id,\r\n      1\r\n    );\r\n    return NEW;\r\n  end if;\r\n\r\n  return null;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "match_status",
    "trigger_name": "trg_audit_match_status",
    "trigger_def": "CREATE TRIGGER trg_audit_match_status AFTER INSERT OR DELETE OR UPDATE ON match_status FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "matches",
    "trigger_name": "trg_audit_matches",
    "trigger_def": "CREATE TRIGGER trg_audit_matches AFTER INSERT OR DELETE OR UPDATE ON matches FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "player",
    "trigger_name": "trg_audit_players",
    "trigger_def": "CREATE TRIGGER trg_audit_players AFTER INSERT OR DELETE OR UPDATE ON player FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "player",
    "trigger_name": "trg_players_touch",
    "trigger_def": "CREATE TRIGGER trg_players_touch BEFORE UPDATE ON player FOR EACH ROW EXECUTE FUNCTION touch_updated_at()",
    "function_name": "touch_updated_at",
    "function_code": "CREATE OR REPLACE FUNCTION public.touch_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  new.updated_at = now();\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "player",
    "trigger_name": "trg_players_tsv",
    "trigger_def": "CREATE TRIGGER trg_players_tsv BEFORE INSERT OR UPDATE OF name, gender_code ON player FOR EACH ROW EXECUTE FUNCTION players_tsv_trigger()",
    "function_name": "players_tsv_trigger",
    "function_code": "CREATE OR REPLACE FUNCTION public.players_tsv_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.search :=\r\n    to_tsvector('simple',\r\n      coalesce(NEW.name,'') || ' ' || coalesce(NEW.gender_code,'')\r\n    );\r\n  RETURN NEW;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "pool_teams",
    "trigger_name": "trg_audit_pool_teams",
    "trigger_def": "CREATE TRIGGER trg_audit_pool_teams AFTER INSERT OR DELETE OR UPDATE ON pool_teams FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "pools",
    "trigger_name": "trg_audit_pools",
    "trigger_def": "CREATE TRIGGER trg_audit_pools AFTER INSERT OR DELETE OR UPDATE ON pools FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "profiles",
    "trigger_name": "trg_audit_user",
    "trigger_def": "CREATE TRIGGER trg_audit_user AFTER INSERT OR DELETE OR UPDATE ON profiles FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "profiles",
    "trigger_name": "trg_user_default_viewer",
    "trigger_def": "CREATE TRIGGER trg_user_default_viewer AFTER INSERT ON profiles FOR EACH ROW EXECUTE FUNCTION assign_default_viewer_role()",
    "function_name": "assign_default_viewer_role",
    "function_code": "CREATE OR REPLACE FUNCTION public.assign_default_viewer_role()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\ndeclare\r\n  v_user_role_id smallint;\r\nbegin\r\n  select r.id::smallint\r\n    into v_user_role_id\r\n  from public.roles r\r\n  where lower(r.name) = 'user'\r\n    and r.scope = 'global'\r\n  limit 1;\r\n\r\n  if v_user_role_id is null then\r\n    raise exception 'Global role \"user\" not found in public.roles';\r\n  end if;\r\n\r\n  insert into public.user_roles (user_id, role_id, granted_by)\r\n  values (new.id, v_user_role_id, new.id)\r\n  on conflict (user_id, role_id) do nothing;\r\n\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "scoreboard_device_subscriptions",
    "trigger_name": "trg_touch_scoreboard_device_subscriptions",
    "trigger_def": "CREATE TRIGGER trg_touch_scoreboard_device_subscriptions BEFORE UPDATE ON scoreboard_device_subscriptions FOR EACH ROW EXECUTE FUNCTION touch_scoreboard_device_subscriptions_updated_at()",
    "function_name": "touch_scoreboard_device_subscriptions_updated_at",
    "function_code": "CREATE OR REPLACE FUNCTION public.touch_scoreboard_device_subscriptions_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  new.updated_at = now();\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "scoreboard_devices",
    "trigger_name": "trg_touch_scoreboard_devices",
    "trigger_def": "CREATE TRIGGER trg_touch_scoreboard_devices BEFORE UPDATE ON scoreboard_devices FOR EACH ROW EXECUTE FUNCTION touch_scoreboard_devices_updated_at()",
    "function_name": "touch_scoreboard_devices_updated_at",
    "function_code": "CREATE OR REPLACE FUNCTION public.touch_scoreboard_devices_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  new.updated_at = now();\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "scoreboard_match_snapshots",
    "trigger_name": "trg_touch_scoreboard_match_snapshots",
    "trigger_def": "CREATE TRIGGER trg_touch_scoreboard_match_snapshots BEFORE UPDATE ON scoreboard_match_snapshots FOR EACH ROW EXECUTE FUNCTION touch_scoreboard_match_snapshots()",
    "function_name": "touch_scoreboard_match_snapshots",
    "function_code": "CREATE OR REPLACE FUNCTION public.touch_scoreboard_match_snapshots()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  new.updated_at = now();\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "spirit_scores",
    "trigger_name": "trg_audit_spirit_scores",
    "trigger_def": "CREATE TRIGGER trg_audit_spirit_scores AFTER INSERT OR DELETE OR UPDATE ON spirit_scores FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "team_roster",
    "trigger_name": "trg_audit_team_roster",
    "trigger_def": "CREATE TRIGGER trg_audit_team_roster AFTER INSERT OR DELETE OR UPDATE ON team_roster FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "team_roster",
    "trigger_name": "trg_roster_touch",
    "trigger_def": "CREATE TRIGGER trg_roster_touch BEFORE UPDATE ON team_roster FOR EACH ROW EXECUTE FUNCTION touch_updated_at()",
    "function_name": "touch_updated_at",
    "function_code": "CREATE OR REPLACE FUNCTION public.touch_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  new.updated_at = now();\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "team_roster",
    "trigger_name": "trg_team_roster_gender",
    "trigger_def": "CREATE TRIGGER trg_team_roster_gender AFTER INSERT OR DELETE OR UPDATE ON team_roster FOR EACH ROW EXECUTE FUNCTION trg_roster_gender_sync()",
    "function_name": "trg_roster_gender_sync",
    "function_code": "CREATE OR REPLACE FUNCTION public.trg_roster_gender_sync()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  PERFORM public.recompute_player_gender(\r\n    COALESCE(NEW.player_id, OLD.player_id)\r\n  );\r\n  RETURN COALESCE(NEW, OLD);\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "teams",
    "trigger_name": "trg_audit_teams",
    "trigger_def": "CREATE TRIGGER trg_audit_teams AFTER INSERT OR DELETE OR UPDATE ON teams FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "user_roles",
    "trigger_name": "trg_audit_user_roles",
    "trigger_def": "CREATE TRIGGER trg_audit_user_roles AFTER INSERT OR DELETE OR UPDATE ON user_roles FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "user_roles",
    "trigger_name": "trg_user_roles_enforce_scope",
    "trigger_def": "CREATE TRIGGER trg_user_roles_enforce_scope BEFORE INSERT OR UPDATE OF role_id ON user_roles FOR EACH ROW EXECUTE FUNCTION enforce_user_roles_global_scope()",
    "function_name": "enforce_user_roles_global_scope",
    "function_code": "CREATE OR REPLACE FUNCTION public.enforce_user_roles_global_scope()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  v_scope text;\r\nbegin\r\n  select scope\r\n    into v_scope\r\n  from public.roles\r\n  where id = new.role_id;\r\n\r\n  if v_scope is null then\r\n    raise exception 'Role % does not exist.', new.role_id;\r\n  end if;\r\n\r\n  if v_scope <> 'global' then\r\n    raise exception\r\n      'Role % has scope \"%\". Only global roles are allowed in user_roles.',\r\n      new.role_id,\r\n      v_scope;\r\n  end if;\r\n\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "webhook_deliveries",
    "trigger_name": "trg_audit_webhook_deliveries",
    "trigger_def": "CREATE TRIGGER trg_audit_webhook_deliveries AFTER INSERT OR DELETE OR UPDATE ON webhook_deliveries FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "public",
    "table_name": "webhook_endpoints",
    "trigger_name": "trg_audit_webhook_endpoints",
    "trigger_def": "CREATE TRIGGER trg_audit_webhook_endpoints AFTER INSERT OR DELETE OR UPDATE ON webhook_endpoints FOR EACH ROW EXECUTE FUNCTION audit_row()",
    "function_name": "audit_row",
    "function_code": "CREATE OR REPLACE FUNCTION public.audit_row()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_pk uuid;\r\n  v_actor uuid;\r\n  v_changed text[];\r\nBEGIN\r\n  BEGIN\r\n    SELECT id INTO v_actor\r\n    FROM public.\"user\"\r\n    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;\r\n  EXCEPTION WHEN others THEN\r\n    v_actor := NULL;\r\n  END;\r\n\r\n  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));\r\n    RETURN NEW;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));\r\n    RETURN OLD;\r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    SELECT array_agg(k)::text[] INTO v_changed\r\n    FROM (\r\n      SELECT n.key AS k\r\n      FROM jsonb_each(to_jsonb(NEW)) n\r\n      WHERE n.key NOT IN ('updated_at','created_at')\r\n        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)\r\n    ) s;\r\n\r\n    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)\r\n    VALUES (\r\n      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,\r\n      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND\r\n$function$\n"
  },
  {
    "schema_name": "realtime",
    "table_name": "subscription",
    "trigger_name": "tr_check_filters",
    "trigger_def": "CREATE TRIGGER tr_check_filters BEFORE INSERT OR UPDATE ON realtime.subscription FOR EACH ROW EXECUTE FUNCTION realtime.subscription_check_filters()",
    "function_name": "subscription_check_filters",
    "function_code": "CREATE OR REPLACE FUNCTION realtime.subscription_check_filters()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n    /*\n    Validates that the user defined filters for a subscription:\n    - refer to valid columns that the claimed role may access\n    - values are coercable to the correct column type\n    */\n    declare\n        col_names text[] = coalesce(\n                array_agg(c.column_name order by c.ordinal_position),\n                '{}'::text[]\n            )\n            from\n                information_schema.columns c\n            where\n                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity\n                and pg_catalog.has_column_privilege(\n                    (new.claims ->> 'role'),\n                    format('%I.%I', c.table_schema, c.table_name)::regclass,\n                    c.column_name,\n                    'SELECT'\n                );\n        filter realtime.user_defined_filter;\n        col_type regtype;\n\n        in_val jsonb;\n    begin\n        for filter in select * from unnest(new.filters) loop\n            -- Filtered column is valid\n            if not filter.column_name = any(col_names) then\n                raise exception 'invalid column for filter %', filter.column_name;\n            end if;\n\n            -- Type is sanitized and safe for string interpolation\n            col_type = (\n                select atttypid::regtype\n                from pg_catalog.pg_attribute\n                where attrelid = new.entity\n                      and attname = filter.column_name\n            );\n            if col_type is null then\n                raise exception 'failed to lookup type for column %', filter.column_name;\n            end if;\n\n            -- Set maximum number of entries for in filter\n            if filter.op = 'in'::realtime.equality_op then\n                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);\n                if coalesce(jsonb_array_length(in_val), 0) > 100 then\n                    raise exception 'too many values for `in` filter. Maximum 100';\n                end if;\n            else\n                -- raises an exception if value is not coercable to type\n                perform realtime.cast(filter.value, col_type);\n            end if;\n\n        end loop;\n\n        -- Apply consistent order to filters so the unique constraint on\n        -- (subscription_id, entity, filters) can't be tricked by a different filter order\n        new.filters = coalesce(\n            array_agg(f order by f.column_name, f.op, f.value),\n            '{}'\n        ) from unnest(new.filters) f;\n\n        return new;\n    end;\n    $function$\n"
  },
  {
    "schema_name": "storage",
    "table_name": "buckets",
    "trigger_name": "enforce_bucket_name_length_trigger",
    "trigger_def": "CREATE TRIGGER enforce_bucket_name_length_trigger BEFORE INSERT OR UPDATE OF name ON storage.buckets FOR EACH ROW EXECUTE FUNCTION storage.enforce_bucket_name_length()",
    "function_name": "enforce_bucket_name_length",
    "function_code": "CREATE OR REPLACE FUNCTION storage.enforce_bucket_name_length()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n    if length(new.name) > 100 then\n        raise exception 'bucket name \"%\" is too long (% characters). Max is 100.', new.name, length(new.name);\n    end if;\n    return new;\nend;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "table_name": "buckets",
    "trigger_name": "protect_buckets_delete",
    "trigger_def": "CREATE TRIGGER protect_buckets_delete BEFORE DELETE ON storage.buckets FOR EACH STATEMENT EXECUTE FUNCTION storage.protect_delete()",
    "function_name": "protect_delete",
    "function_code": "CREATE OR REPLACE FUNCTION storage.protect_delete()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Check if storage.allow_delete_query is set to 'true'\n    IF COALESCE(current_setting('storage.allow_delete_query', true), 'false') != 'true' THEN\n        RAISE EXCEPTION 'Direct deletion from storage tables is not allowed. Use the Storage API instead.'\n            USING HINT = 'This prevents accidental data loss from orphaned objects.',\n                  ERRCODE = '42501';\n    END IF;\n    RETURN NULL;\nEND;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "trigger_name": "protect_objects_delete",
    "trigger_def": "CREATE TRIGGER protect_objects_delete BEFORE DELETE ON storage.objects FOR EACH STATEMENT EXECUTE FUNCTION storage.protect_delete()",
    "function_name": "protect_delete",
    "function_code": "CREATE OR REPLACE FUNCTION storage.protect_delete()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Check if storage.allow_delete_query is set to 'true'\n    IF COALESCE(current_setting('storage.allow_delete_query', true), 'false') != 'true' THEN\n        RAISE EXCEPTION 'Direct deletion from storage tables is not allowed. Use the Storage API instead.'\n            USING HINT = 'This prevents accidental data loss from orphaned objects.',\n                  ERRCODE = '42501';\n    END IF;\n    RETURN NULL;\nEND;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "trigger_name": "update_objects_updated_at",
    "trigger_def": "CREATE TRIGGER update_objects_updated_at BEFORE UPDATE ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.update_updated_at_column()",
    "function_name": "update_updated_at_column",
    "function_code": "CREATE OR REPLACE FUNCTION storage.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW; \nEND;\n$function$\n"
  }
]