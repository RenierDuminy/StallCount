| trigger_name                 | schema_name | table_name         | trigger_definition                                                                                                                               | function_name          | function_definition                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| ---------------------------- | ----------- | ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| trg_audit_bracket_nodes      | public      | bracket_nodes      | CREATE TRIGGER trg_audit_bracket_nodes AFTER INSERT OR DELETE OR UPDATE ON bracket_nodes FOR EACH ROW EXECUTE FUNCTION audit_row()               | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |
| trg_audit_brackets           | public      | brackets           | CREATE TRIGGER trg_audit_brackets AFTER INSERT OR DELETE OR UPDATE ON brackets FOR EACH ROW EXECUTE FUNCTION audit_row()                         | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |
| trg_audit_division_teams     | public      | division_teams     | CREATE TRIGGER trg_audit_division_teams AFTER INSERT OR DELETE OR UPDATE ON division_teams FOR EACH ROW EXECUTE FUNCTION audit_row()             | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |
| trg_audit_divisions          | public      | divisions          | CREATE TRIGGER trg_audit_divisions AFTER INSERT OR DELETE OR UPDATE ON divisions FOR EACH ROW EXECUTE FUNCTION audit_row()                       | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |
| trg_audit_events             | public      | events             | CREATE TRIGGER trg_audit_events AFTER INSERT OR DELETE OR UPDATE ON events FOR EACH ROW EXECUTE FUNCTION audit_row()                             | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |
| trg_audit_live_events        | public      | live_events        | CREATE TRIGGER trg_audit_live_events AFTER INSERT OR DELETE OR UPDATE ON live_events FOR EACH ROW EXECUTE FUNCTION audit_row()                   | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |
| trg_audit_match_events       | public      | match_events       | CREATE TRIGGER trg_audit_match_events AFTER INSERT OR DELETE OR UPDATE ON match_events FOR EACH ROW EXECUTE FUNCTION audit_row()                 | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |
| trg_audit_match_logs         | public      | match_logs         | CREATE TRIGGER trg_audit_match_logs AFTER INSERT OR DELETE OR UPDATE ON match_logs FOR EACH ROW EXECUTE FUNCTION audit_row()                     | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |
| trg_audit_match_status       | public      | match_status       | CREATE TRIGGER trg_audit_match_status AFTER INSERT OR DELETE OR UPDATE ON match_status FOR EACH ROW EXECUTE FUNCTION audit_row()                 | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |
| trg_audit_matches            | public      | matches            | CREATE TRIGGER trg_audit_matches AFTER INSERT OR DELETE OR UPDATE ON matches FOR EACH ROW EXECUTE FUNCTION audit_row()                           | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |
| trg_matches_media_normalize  | public      | matches            | CREATE TRIGGER trg_matches_media_normalize BEFORE INSERT OR UPDATE OF media_link ON matches FOR EACH ROW EXECUTE FUNCTION normalize_media_link() | normalize_media_link   | CREATE OR REPLACE FUNCTION public.normalize_media_link()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
DECLARE
  j   jsonb := NEW.media_link;
  p   jsonb;
  prov text;
  url  text;
  st   text;
BEGIN
  IF j IS NULL THEN
    RETURN NEW;
  END IF;

  -- Allow raw string -> wrap as primary.url
  IF jsonb_typeof(j) = 'string' THEN
    j := jsonb_build_object('primary', jsonb_build_object('provider','custom','url', j::text));
  END IF;

  p    := j->'primary';
  prov := lower(COALESCE(p->>'provider','custom'));
  url  := btrim(p->>'url');

  -- If primary.status missing, mirror matches.status (TEXT lookup)
  st := COALESCE(p->>'status', NEW.status);

  -- Derive embed for YouTube if absent
  IF prov = 'youtube' AND (p ? 'embed_url') IS FALSE THEN
    j := jsonb_set(
          j, '{primary,embed_url}',
          to_jsonb(
            CASE
              WHEN url ~* 'youtu\.be/([A-Za-z0-9_-]{6,})'
                THEN 'https://www.youtube.com/embed/' || regexp_replace(url, '.*youtu\.be/([^?&/]+).*', '\1')
              WHEN url ~* 'v=([A-Za-z0-9_-]{6,})'
                THEN 'https://www.youtube.com/embed/' || regexp_replace(url, '.*[?&]v=([^?&/]+).*', '\1')
              ELSE NULL
            END
          ),
          true
        );
  END IF;

  j := jsonb_set(j,'{primary,provider}', to_jsonb(prov), true);
  j := jsonb_set(j,'{primary,status}',   to_jsonb(st),   true);

  -- Fill start_time if missing
  IF (p ? 'start_time') IS FALSE AND NEW.start_time IS NOT NULL THEN
    j := jsonb_set(j,'{primary,start_time}', to_jsonb(NEW.start_time), true);
  END IF;

  NEW.media_link := j;
  RETURN NEW;
END
$function$
 |
| trg_audit_players            | public      | player             | CREATE TRIGGER trg_audit_players AFTER INSERT OR DELETE OR UPDATE ON player FOR EACH ROW EXECUTE FUNCTION audit_row()                            | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |
| trg_players_touch            | public      | player             | CREATE TRIGGER trg_players_touch BEFORE UPDATE ON player FOR EACH ROW EXECUTE FUNCTION touch_updated_at()                                        | touch_updated_at       | CREATE OR REPLACE FUNCTION public.touch_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN NEW.updated_at := now(); RETURN NEW; END
$function$
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| trg_players_tsv              | public      | player             | CREATE TRIGGER trg_players_tsv BEFORE INSERT OR UPDATE OF name, gender_code ON player FOR EACH ROW EXECUTE FUNCTION players_tsv_trigger()        | players_tsv_trigger    | CREATE OR REPLACE FUNCTION public.players_tsv_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.search :=
    to_tsvector('simple',
      coalesce(NEW.name,'') || ' ' || coalesce(NEW.gender_code,'')
    );
  RETURN NEW;
END
$function$
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| trg_audit_pool_teams         | public      | pool_teams         | CREATE TRIGGER trg_audit_pool_teams AFTER INSERT OR DELETE OR UPDATE ON pool_teams FOR EACH ROW EXECUTE FUNCTION audit_row()                     | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |
| trg_audit_pools              | public      | pools              | CREATE TRIGGER trg_audit_pools AFTER INSERT OR DELETE OR UPDATE ON pools FOR EACH ROW EXECUTE FUNCTION audit_row()                               | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |
| trg_audit_spirit_scores      | public      | spirit_scores      | CREATE TRIGGER trg_audit_spirit_scores AFTER INSERT OR DELETE OR UPDATE ON spirit_scores FOR EACH ROW EXECUTE FUNCTION audit_row()               | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |
| trg_audit_team_roster        | public      | team_roster        | CREATE TRIGGER trg_audit_team_roster AFTER INSERT OR DELETE OR UPDATE ON team_roster FOR EACH ROW EXECUTE FUNCTION audit_row()                   | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |
| trg_roster_touch             | public      | team_roster        | CREATE TRIGGER trg_roster_touch BEFORE UPDATE ON team_roster FOR EACH ROW EXECUTE FUNCTION touch_updated_at()                                    | touch_updated_at       | CREATE OR REPLACE FUNCTION public.touch_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN NEW.updated_at := now(); RETURN NEW; END
$function$
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| trg_team_roster_gender       | public      | team_roster        | CREATE TRIGGER trg_team_roster_gender AFTER INSERT OR DELETE OR UPDATE ON team_roster FOR EACH ROW EXECUTE FUNCTION trg_roster_gender_sync()     | trg_roster_gender_sync | CREATE OR REPLACE FUNCTION public.trg_roster_gender_sync()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  PERFORM public.recompute_player_gender(
    COALESCE(NEW.player_id, OLD.player_id)
  );
  RETURN COALESCE(NEW, OLD);
END
$function$
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| trg_audit_teams              | public      | teams              | CREATE TRIGGER trg_audit_teams AFTER INSERT OR DELETE OR UPDATE ON teams FOR EACH ROW EXECUTE FUNCTION audit_row()                               | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |
| trg_audit_webhook_deliveries | public      | webhook_deliveries | CREATE TRIGGER trg_audit_webhook_deliveries AFTER INSERT OR DELETE OR UPDATE ON webhook_deliveries FOR EACH ROW EXECUTE FUNCTION audit_row()     | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |
| trg_audit_webhook_endpoints  | public      | webhook_endpoints  | CREATE TRIGGER trg_audit_webhook_endpoints AFTER INSERT OR DELETE OR UPDATE ON webhook_endpoints FOR EACH ROW EXECUTE FUNCTION audit_row()       | audit_row              | CREATE OR REPLACE FUNCTION public.audit_row()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_pk uuid;
  v_actor uuid;
  v_changed text[];
BEGIN
  BEGIN
    SELECT id INTO v_actor
    FROM public."user"
    WHERE id = NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub','')::uuid;
  EXCEPTION WHEN others THEN
    v_actor := NULL;
  END;

  BEGIN v_pk := COALESCE(NEW.id, OLD.id); EXCEPTION WHEN others THEN v_pk := NULL; END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'INSERT', v_actor, jsonb_build_object('new', to_jsonb(NEW)));
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (TG_TABLE_NAME, v_pk, 'DELETE', v_actor, jsonb_build_object('old', to_jsonb(OLD)));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    SELECT array_agg(k)::text[] INTO v_changed
    FROM (
      SELECT n.key AS k
      FROM jsonb_each(to_jsonb(NEW)) n
      WHERE n.key NOT IN ('updated_at','created_at')
        AND n.value IS DISTINCT FROM (to_jsonb(OLD)->n.key)
    ) s;

    IF v_changed IS NULL OR array_length(v_changed,1) IS NULL THEN
      RETURN NEW;
    END IF;

    INSERT INTO public.audit_log(table_name, record_id, action, actor_id, change_data)
    VALUES (
      TG_TABLE_NAME, v_pk, 'UPDATE', v_actor,
      jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW), 'changed_cols', v_changed)
    );
    RETURN NEW;
  END IF;

  RETURN NULL;
END
$function$
                                   |